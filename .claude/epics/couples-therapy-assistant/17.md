---
name: RAG Context & Pattern Recognition
status: closed
created: 2025-12-23T20:56:49Z
updated: 2025-12-25T18:23:45Z
github: https://github.com/vadimalpha/taskmanager/issues/17
depends_on: [13, 16]
parallel: false
conflicts_with: []
---

# Task: RAG Context & Pattern Recognition

## Description

Implement SurrealDB vector search to retrieve relevant intake survey data and conflict history for RAG-powered personalization. Build pattern recognition engine to detect recurring themes (e.g., "finances mentioned 4x in 60 days") and relationship cycles (pursue-withdraw, mutual criticism). Inject RAG context and pattern insights into LLM prompts.

## Acceptance Criteria

- [ ] SurrealDB vector embeddings generated for:
  - Intake survey text responses (concatenated)
  - Conflict descriptions (Partner A + Partner B)
- [ ] Vector similarity search retrieves last 5 conflicts for RAG context
- [ ] Pattern recognition detects:
  - Recurring themes (same keyword/topic mentioned 3+ times in 30 days)
  - Conflict frequency (e.g., "4 conflicts about finances in 60 days")
  - Relationship cycles (pursue-withdraw, demand-withdraw, mutual criticism)
- [ ] RAG context injected into all 5 prompts (intake data + last 5 conflicts)
- [ ] Pattern insights injected into Prompts 2A, 2B, 3
- [ ] Pattern insights displayed in UI (e.g., "Pattern Detected: You've had 3 conflicts about household chores in the past month")

## Technical Details

**Vector Embedding Generation**:
```typescript
// Use Anthropic's text embedding API (or OpenAI ada-002)
async function generateEmbedding(text: string): Promise<number[]> {
  const response = await fetch('https://api.anthropic.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': process.env.ANTHROPIC_API_KEY
    },
    body: JSON.stringify({
      model: 'voyage-2',
      input: text
    })
  });

  const data = await response.json();
  return data.embedding;
}

// Generate embeddings on intake survey completion
async function onIntakeSurveyComplete(userId: string, intakeData: IntakeData) {
  const textResponses = [
    intakeData.conflict_triggers,
    intakeData.communication_patterns,
    intakeData.previous_relationship_history,
    intakeData.relationship_goals,
    intakeData.values_alignment
  ].join(' ');

  const embedding = await generateEmbedding(textResponses);

  await db.query(`
    UPDATE ${userId} SET intake_data.embedding = ${embedding}
  `);
}

// Generate embeddings on conflict creation
async function onConflictCreated(conflictId: string) {
  const conflict = await db.select(conflictId);
  const combinedText = `${conflict.title}. ${conflict.partner_a_description}`;
  const embedding = await generateEmbedding(combinedText);

  await db.query(`
    UPDATE ${conflictId} SET embedding = ${embedding}
  `);
}
```

**Vector Similarity Search** (SurrealDB):
```surrealql
-- Retrieve last 5 most similar conflicts
LET $current_conflict_embedding = (SELECT embedding FROM conflicts WHERE id = $conflict_id);

SELECT id, title, partner_a_description, partner_b_description, created_at
FROM conflicts
WHERE relationship_id = $relationship_id
  AND id != $conflict_id
ORDER BY vector::similarity::cosine(embedding, $current_conflict_embedding) DESC
LIMIT 5;
```

**Pattern Recognition Engine** (`src/services/pattern-recognition.ts`):
```typescript
export class PatternRecognitionEngine {
  async detectPatterns(conflictId: string): Promise<PatternInsights> {
    const conflict = await db.select(conflictId);
    const recentConflicts = await this.getRecentConflicts(
      conflict.relationship_id,
      90 // days
    );

    const themeFrequency = this.analyzeThemeFrequency(recentConflicts);
    const relationshipCycles = this.detectRelationshipCycles(recentConflicts);

    return {
      recurring_themes: themeFrequency,
      relationship_cycles: relationshipCycles,
      frequency_alerts: this.generateFrequencyAlerts(themeFrequency)
    };
  }

  private analyzeThemeFrequency(conflicts: Conflict[]): ThemeFrequency[] {
    const themes = [
      'finances', 'money', 'chores', 'housework', 'intimacy', 'sex',
      'communication', 'listening', 'family', 'in-laws', 'parenting',
      'work', 'career', 'time', 'quality time'
    ];

    const frequency: Record<string, number> = {};

    conflicts.forEach(conflict => {
      const text = `${conflict.title} ${conflict.partner_a_description} ${conflict.partner_b_description}`.toLowerCase();

      themes.forEach(theme => {
        if (text.includes(theme)) {
          frequency[theme] = (frequency[theme] || 0) + 1;
        }
      });
    });

    // Return themes mentioned 3+ times
    return Object.entries(frequency)
      .filter(([_, count]) => count >= 3)
      .map(([theme, count]) => ({ theme, count }));
  }

  private detectRelationshipCycles(conflicts: Conflict[]): RelationshipCycle[] {
    // Simple heuristic: Look for keywords indicating pursue-withdraw
    const pursueKeywords = ['ask', 'request', 'beg', 'demand', 'need', 'want'];
    const withdrawKeywords = ['ignore', 'shut down', 'silent', 'avoid', 'withdraw'];

    let pursueCount = 0;
    let withdrawCount = 0;

    conflicts.forEach(conflict => {
      const textA = conflict.partner_a_description.toLowerCase();
      const textB = conflict.partner_b_description?.toLowerCase() || '';

      if (pursueKeywords.some(kw => textA.includes(kw))) pursueCount++;
      if (withdrawKeywords.some(kw => textB.includes(kw))) withdrawCount++;
    });

    if (pursueCount >= 3 && withdrawCount >= 3) {
      return [{
        type: 'pursue-withdraw',
        description: 'Partner A tends to pursue (make requests), Partner B tends to withdraw',
        frequency: Math.min(pursueCount, withdrawCount)
      }];
    }

    return [];
  }

  private generateFrequencyAlerts(themes: ThemeFrequency[]): string[] {
    return themes.map(({ theme, count }) =>
      `This is the ${count}${this.ordinalSuffix(count)} time "${theme}" has created tension in the past 90 days.`
    );
  }
}
```

**Integration with AI Orchestrator**:
```typescript
// In AI Orchestrator prompt builder
async buildPrompt(templatePath: string, context: any) {
  const template = await fs.readFile(templatePath, 'utf-8');

  // Add RAG context
  const ragContext = await this.getRAGContext(context.conflict_id);
  context.conflict_history = ragContext.recent_conflicts;

  // Add pattern insights (for Prompts 2A/2B/3)
  if (templatePath.includes('joint-context') || templatePath.includes('relationship')) {
    const patterns = await patternEngine.detectPatterns(context.conflict_id);
    context.pattern_insights = patterns.frequency_alerts.join('\n');
  }

  // Replace template variables
  return template.replace(/{{(\w+)}}/g, (_, key) => context[key] || '');
}
```

**Frontend Pattern Display**:
- Show pattern insights in a collapsible "Pattern Recognition" section
- Use warning icon for recurring themes (e.g., "⚠️ Recurring Theme: Finances")
- Suggest "Consider scheduling a dedicated conversation about..." for 3+ occurrences

## Dependencies

- [ ] Task 1 complete (conflicts table with embedding field)
- [ ] Task 4 complete (AI Orchestrator, prompt templates)
- [ ] Anthropic/OpenAI embedding API access

## Effort Estimate

- **Size**: M
- **Hours**: 32-40 hours (4-5 days)
- **Parallel**: false (depends on Task 4 completion)

## Definition of Done

- [ ] Vector embeddings generated for intake surveys and conflicts
- [ ] Vector similarity search retrieves last 5 conflicts
- [ ] Pattern recognition detects recurring themes (3+ occurrences in 30 days)
- [ ] Pattern recognition detects relationship cycles (pursue-withdraw)
- [ ] RAG context injected into all 5 prompts
- [ ] Pattern insights injected into Prompts 2A/2B/3
- [ ] Pattern insights displayed in UI (Guidance Display component)
- [ ] Unit tests for pattern recognition logic
- [ ] Integration test: Create 5 conflicts with same theme, verify pattern detected
- [ ] E2E test: User creates multiple conflicts, sees pattern alert
