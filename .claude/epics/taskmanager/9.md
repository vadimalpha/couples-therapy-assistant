---
name: Offline Support
status: open
created: 2025-08-26T18:29:07Z
updated: 2025-08-26T20:52:21Z
github: https://github.com/vadimalpha/taskmanager/issues/9
depends_on: [004, 005, 006, 007]
parallel: true
conflicts_with: []
---

# Task: Offline Support

## Description
Implement offline-first functionality using Service Workers for caching, background sync, and conflict resolution to ensure the app works without internet connection.

## Acceptance Criteria
- [ ] Service Worker registered and caching static assets
- [ ] Offline task creation and editing
- [ ] Background sync when connection restored
- [ ] Conflict resolution for concurrent edits
- [ ] Visual indicator for offline/online status
- [ ] Queue display for pending syncs
- [ ] Cache invalidation strategy
- [ ] PWA manifest for installability

## Detailed Implementation Specifications

### 1. Service Worker Architecture

Create `public/sw.js` (Service Worker main file):
```javascript
// Service Worker version for cache busting
const CACHE_VERSION = 'v1.0.0';
const STATIC_CACHE = `taskmanager-static-${CACHE_VERSION}`;
const API_CACHE = `taskmanager-api-${CACHE_VERSION}`;
const OFFLINE_PAGE = '/offline';

// Static assets to cache
const STATIC_ASSETS = [
  '/',
  '/offline',
  '/manifest.json',
  '/_next/static/css/',  // Will cache dynamically
  '/_next/static/chunks/', // Will cache dynamically
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
];

// API endpoints to cache
const API_ENDPOINTS = [
  '/api/tasks',
  '/api/projects',
  '/api/priorities',
  '/api/suggestions'
];

self.addEventListener('install', event => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    (async () => {
      const cache = await caches.open(STATIC_CACHE);
      
      try {
        await cache.addAll(STATIC_ASSETS);
        console.log('Static assets cached successfully');
      } catch (error) {
        console.error('Failed to cache static assets:', error);
        // Cache available assets individually
        for (const asset of STATIC_ASSETS) {
          try {
            await cache.add(asset);
          } catch (err) {
            console.warn(`Failed to cache ${asset}:`, err);
          }
        }
      }
      
      // Skip waiting to activate immediately
      self.skipWaiting();
    })()
  );
});

self.addEventListener('activate', event => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    (async () => {
      // Clean up old caches
      const cacheNames = await caches.keys();
      const oldCaches = cacheNames.filter(name => 
        name.startsWith('taskmanager-') && 
        !name.includes(CACHE_VERSION)
      );
      
      await Promise.all(
        oldCaches.map(cacheName => {
          console.log('Deleting old cache:', cacheName);
          return caches.delete(cacheName);
        })
      );
      
      // Take control of all clients
      self.clients.claim();
      
      console.log('Service Worker activated');
    })()
  );
});

self.addEventListener('fetch', event => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Skip non-GET requests and chrome-extension requests
  if (request.method !== 'GET' || url.protocol === 'chrome-extension:') {
    return;
  }
  
  // Handle API requests
  if (url.pathname.startsWith('/api/')) {
    event.respondWith(handleApiRequest(request));
    return;
  }
  
  // Handle static assets and pages
  event.respondWith(handleStaticRequest(request));
});

async function handleApiRequest(request) {
  const url = new URL(request.url);
  const cache = await caches.open(API_CACHE);
  
  try {
    // Try network first
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      // Cache successful responses
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    console.log('Network request failed, trying cache:', url.pathname);
    
    // Try cache when network fails
    const cachedResponse = await cache.match(request);
    
    if (cachedResponse) {
      // Add offline header to indicate cached response
      const response = cachedResponse.clone();
      response.headers.set('X-Offline-Response', 'true');
      return response;
    }
    
    // Return offline response for specific endpoints
    if (url.pathname.includes('/api/tasks')) {
      return new Response(JSON.stringify([]), {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'X-Offline-Response': 'true'
        }
      });
    }
    
    throw error;
  }
}

async function handleStaticRequest(request) {
  const cache = await caches.open(STATIC_CACHE);
  
  // Try cache first for static assets
  const cachedResponse = await cache.match(request);
  if (cachedResponse) {
    return cachedResponse;
  }
  
  try {
    // Try network
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      // Cache successful responses
      cache.put(request, networkResponse.clone());
    }
    
    return networkResponse;
  } catch (error) {
    // Return offline page for navigation requests
    if (request.mode === 'navigate') {
      const offlineResponse = await cache.match(OFFLINE_PAGE);
      if (offlineResponse) {
        return offlineResponse;
      }
    }
    
    throw error;
  }
}

// Background Sync for offline operations
self.addEventListener('sync', event => {
  console.log('Background sync triggered:', event.tag);
  
  if (event.tag === 'sync-tasks') {
    event.waitUntil(syncPendingTasks());
  } else if (event.tag === 'sync-priorities') {
    event.waitUntil(syncPendingPriorities());
  }
});

async function syncPendingTasks() {
  try {
    // Open IndexedDB to get pending operations
    const db = await openIndexedDB();
    const transaction = db.transaction(['syncQueue'], 'readonly');
    const store = transaction.objectStore('syncQueue');
    const pendingOps = await getAllFromStore(store);
    
    for (const operation of pendingOps) {
      try {
        await retryOperation(operation);
        
        // Remove successful operation from queue
        const deleteTransaction = db.transaction(['syncQueue'], 'readwrite');
        const deleteStore = deleteTransaction.objectStore('syncQueue');
        await deleteStore.delete(operation.id);
        
      } catch (error) {
        console.error('Failed to sync operation:', operation, error);
        // Update retry count
        operation.retryCount = (operation.retryCount || 0) + 1;
        
        if (operation.retryCount < 3) {
          const updateTransaction = db.transaction(['syncQueue'], 'readwrite');
          const updateStore = updateTransaction.objectStore('syncQueue');
          await updateStore.put(operation);
        } else {
          // Remove after 3 failed attempts
          const deleteTransaction = db.transaction(['syncQueue'], 'readwrite');
          const deleteStore = deleteTransaction.objectStore('syncQueue');
          await deleteStore.delete(operation.id);
        }
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

async function retryOperation(operation) {
  const { method, url, data, headers } = operation;
  
  const response = await fetch(url, {
    method,
    headers: headers || { 'Content-Type': 'application/json' },
    body: data ? JSON.stringify(data) : undefined
  });
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  
  return response;
}

// Push notifications for sync completion
self.addEventListener('message', event => {
  const { type, payload } = event.data;
  
  if (type === 'QUEUE_OPERATION') {
    queueOperation(payload);
  } else if (type === 'TRIGGER_SYNC') {
    self.registration.sync.register(payload.tag || 'sync-tasks');
  }
});

async function queueOperation(operation) {
  try {
    const db = await openIndexedDB();
    const transaction = db.transaction(['syncQueue'], 'readwrite');
    const store = transaction.objectStore('syncQueue');
    
    await store.add({
      ...operation,
      id: Date.now() + Math.random(),
      timestamp: new Date().toISOString(),
      retryCount: 0
    });
    
    console.log('Operation queued for sync:', operation);
  } catch (error) {
    console.error('Failed to queue operation:', error);
  }
}

// IndexedDB helper functions
function openIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('TaskManagerOffline', 1);
    
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    
    request.onupgradeneeded = event => {
      const db = event.target.result;
      
      // Create sync queue store
      if (!db.objectStoreNames.contains('syncQueue')) {
        const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id' });
        syncStore.createIndex('timestamp', 'timestamp');
        syncStore.createIndex('type', 'type');
      }
      
      // Create offline data store
      if (!db.objectStoreNames.contains('offlineData')) {
        const dataStore = db.createObjectStore('offlineData', { keyPath: 'key' });
        dataStore.createIndex('type', 'type');
        dataStore.createIndex('lastModified', 'lastModified');
      }
    };
  });
}

function getAllFromStore(store) {
  return new Promise((resolve, reject) => {
    const request = store.getAll();
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
  });
}
```

### 2. Offline Storage Manager

Create `lib/offline/storage.ts`:
```typescript
interface OfflineOperation {
  id: string;
  type: 'create' | 'update' | 'delete';
  entity: 'task' | 'project' | 'priority';
  data: any;
  url: string;
  method: string;
  timestamp: string;
  retryCount: number;
}

interface OfflineData {
  key: string;
  type: string;
  data: any;
  lastModified: string;
  syncStatus: 'pending' | 'synced' | 'conflict';
}

export class OfflineStorageManager {
  private db: IDBDatabase | null = null;
  private readonly dbName = 'TaskManagerOffline';
  private readonly dbVersion = 1;

  async initialize(): Promise<void> {
    if (this.db) return;
    
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.dbVersion);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };
      
      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        this.setupDatabase(db);
      };
    });
  }

  private setupDatabase(db: IDBDatabase): void {
    // Sync queue store
    if (!db.objectStoreNames.contains('syncQueue')) {
      const syncStore = db.createObjectStore('syncQueue', { keyPath: 'id' });
      syncStore.createIndex('timestamp', 'timestamp');
      syncStore.createIndex('type', 'type');
      syncStore.createIndex('entity', 'entity');
    }

    // Offline data store
    if (!db.objectStoreNames.contains('offlineData')) {
      const dataStore = db.createObjectStore('offlineData', { keyPath: 'key' });
      dataStore.createIndex('type', 'type');
      dataStore.createIndex('lastModified', 'lastModified');
      dataStore.createIndex('syncStatus', 'syncStatus');
    }
  }

  async storeData(key: string, type: string, data: any): Promise<void> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['offlineData'], 'readwrite');
    const store = transaction.objectStore('offlineData');
    
    const offlineData: OfflineData = {
      key,
      type,
      data,
      lastModified: new Date().toISOString(),
      syncStatus: 'pending'
    };
    
    await this.promisifyRequest(store.put(offlineData));
  }

  async getData(key: string): Promise<any | null> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['offlineData'], 'readonly');
    const store = transaction.objectStore('offlineData');
    
    const result = await this.promisifyRequest(store.get(key));
    return result?.data || null;
  }

  async getAllDataByType(type: string): Promise<any[]> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['offlineData'], 'readonly');
    const store = transaction.objectStore('offlineData');
    const index = store.index('type');
    
    const results = await this.promisifyRequest(index.getAll(type));
    return results.map((item: OfflineData) => item.data);
  }

  async queueOperation(operation: Omit<OfflineOperation, 'id' | 'timestamp' | 'retryCount'>): Promise<void> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['syncQueue'], 'readwrite');
    const store = transaction.objectStore('syncQueue');
    
    const queueItem: OfflineOperation = {
      ...operation,
      id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      timestamp: new Date().toISOString(),
      retryCount: 0
    };
    
    await this.promisifyRequest(store.add(queueItem));
    
    // Trigger background sync if available
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      try {
        const registration = await navigator.serviceWorker.ready;
        await registration.sync.register('sync-tasks');
      } catch (error) {
        console.warn('Background sync not supported:', error);
      }
    }
  }

  async getPendingOperations(): Promise<OfflineOperation[]> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['syncQueue'], 'readonly');
    const store = transaction.objectStore('syncQueue');
    
    return await this.promisifyRequest(store.getAll());
  }

  async removeOperation(id: string): Promise<void> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['syncQueue'], 'readwrite');
    const store = transaction.objectStore('syncQueue');
    
    await this.promisifyRequest(store.delete(id));
  }

  async updateSyncStatus(key: string, status: 'pending' | 'synced' | 'conflict'): Promise<void> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['offlineData'], 'readwrite');
    const store = transaction.objectStore('offlineData');
    
    const existing = await this.promisifyRequest(store.get(key));
    if (existing) {
      existing.syncStatus = status;
      await this.promisifyRequest(store.put(existing));
    }
  }

  async clearData(type?: string): Promise<void> {
    if (!this.db) await this.initialize();
    
    const transaction = this.db!.transaction(['offlineData'], 'readwrite');
    const store = transaction.objectStore('offlineData');
    
    if (type) {
      const index = store.index('type');
      const keys = await this.promisifyRequest(index.getAllKeys(type));
      for (const key of keys) {
        await this.promisifyRequest(store.delete(key));
      }
    } else {
      await this.promisifyRequest(store.clear());
    }
  }

  private promisifyRequest<T>(request: IDBRequest<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
}

export const offlineStorage = new OfflineStorageManager();
```

### 3. Offline Task Store

Create `lib/stores/offlineTaskStore.ts`:
```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { Task } from '../types/task';
import { offlineStorage } from '../offline/storage';

interface OfflineTaskState {
  // Data
  offlineTasks: Map<string, Task>;
  pendingOperations: any[];
  
  // Connection Status
  isOnline: boolean;
  isSyncing: boolean;
  lastSyncTime: Date | null;
  syncErrors: string[];
  
  // Actions
  createOfflineTask: (task: Omit<Task, 'id' | 'createdAt' | 'updatedAt'>) => Promise<Task>;
  updateOfflineTask: (id: string, updates: Partial<Task>) => Promise<void>;
  deleteOfflineTask: (id: string) => Promise<void>;
  syncTasks: () => Promise<void>;
  loadOfflineTasks: () => Promise<void>;
  setOnlineStatus: (online: boolean) => void;
  clearSyncErrors: () => void;
  
  // Getters
  getOfflineTask: (id: string) => Task | undefined;
  getAllOfflineTasks: () => Task[];
  getPendingSyncCount: () => number;
}

export const useOfflineTaskStore = create<OfflineTaskState>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial State
        offlineTasks: new Map(),
        pendingOperations: [],
        isOnline: navigator.onLine,
        isSyncing: false,
        lastSyncTime: null,
        syncErrors: [],

        // Actions
        createOfflineTask: async (taskData) => {
          const task: Task = {
            ...taskData,
            id: `offline_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            isOffline: true
          };

          // Store in memory
          set(state => ({
            offlineTasks: new Map(state.offlineTasks.set(task.id, task))
          }));

          // Store in IndexedDB
          await offlineStorage.storeData(`task_${task.id}`, 'task', task);

          // Queue for sync when online
          if (get().isOnline) {
            await offlineStorage.queueOperation({
              type: 'create',
              entity: 'task',
              data: task,
              url: '/api/tasks',
              method: 'POST'
            });
          }

          return task;
        },

        updateOfflineTask: async (id, updates) => {
          const currentTask = get().offlineTasks.get(id);
          if (!currentTask) return;

          const updatedTask: Task = {
            ...currentTask,
            ...updates,
            updatedAt: new Date().toISOString()
          };

          // Update in memory
          set(state => ({
            offlineTasks: new Map(state.offlineTasks.set(id, updatedTask))
          }));

          // Update in IndexedDB
          await offlineStorage.storeData(`task_${id}`, 'task', updatedTask);

          // Queue for sync when online
          if (get().isOnline) {
            await offlineStorage.queueOperation({
              type: 'update',
              entity: 'task',
              data: updatedTask,
              url: `/api/tasks/${id}`,
              method: 'PUT'
            });
          }
        },

        deleteOfflineTask: async (id) => {
          const task = get().offlineTasks.get(id);
          if (!task) return;

          // Remove from memory
          set(state => {
            const newTasks = new Map(state.offlineTasks);
            newTasks.delete(id);
            return { offlineTasks: newTasks };
          });

          // Mark as deleted in IndexedDB (don't actually delete until synced)
          if (task.isOffline) {
            // If it's an offline-only task, remove it completely
            await offlineStorage.removeOperation(id);
          } else {
            // Queue deletion for server
            await offlineStorage.queueOperation({
              type: 'delete',
              entity: 'task',
              data: { id },
              url: `/api/tasks/${id}`,
              method: 'DELETE'
            });
          }
        },

        syncTasks: async () => {
          if (!get().isOnline || get().isSyncing) return;

          set({ isSyncing: true, syncErrors: [] });

          try {
            const pendingOps = await offlineStorage.getPendingOperations();
            const errors: string[] = [];

            for (const operation of pendingOps) {
              try {
                await syncOperation(operation);
                await offlineStorage.removeOperation(operation.id);
              } catch (error) {
                console.error('Sync operation failed:', error);
                errors.push(`Failed to sync ${operation.type} operation: ${error.message}`);
                
                // Update retry count
                operation.retryCount = (operation.retryCount || 0) + 1;
                if (operation.retryCount >= 3) {
                  // Remove after 3 failed attempts
                  await offlineStorage.removeOperation(operation.id);
                  errors.push(`Operation abandoned after 3 retries: ${operation.type}`);
                }
              }
            }

            // Load fresh data from server
            await loadServerTasks();

            set({
              isSyncing: false,
              lastSyncTime: new Date(),
              syncErrors: errors
            });

          } catch (error) {
            set({
              isSyncing: false,
              syncErrors: [`Sync failed: ${error.message}`]
            });
          }
        },

        loadOfflineTasks: async () => {
          try {
            await offlineStorage.initialize();
            const offlineTasks = await offlineStorage.getAllDataByType('task');
            
            const taskMap = new Map();
            offlineTasks.forEach(task => taskMap.set(task.id, task));
            
            set({ offlineTasks: taskMap });
          } catch (error) {
            console.error('Failed to load offline tasks:', error);
          }
        },

        setOnlineStatus: (online) => {
          set({ isOnline: online });
          
          if (online) {
            // Auto-sync when coming back online
            setTimeout(() => {
              get().syncTasks();
            }, 1000);
          }
        },

        clearSyncErrors: () => {
          set({ syncErrors: [] });
        },

        // Getters
        getOfflineTask: (id) => {
          return get().offlineTasks.get(id);
        },

        getAllOfflineTasks: () => {
          return Array.from(get().offlineTasks.values());
        },

        getPendingSyncCount: () => {
          return get().pendingOperations.length;
        }
      }),
      {
        name: 'offline-task-store',
        partialize: (state) => ({
          offlineTasks: Array.from(state.offlineTasks.entries()),
          lastSyncTime: state.lastSyncTime
        }),
        onRehydrateStorage: () => (state) => {
          if (state?.offlineTasks) {
            state.offlineTasks = new Map(state.offlineTasks as any);
          }
        }
      }
    ),
    { name: 'OfflineTaskStore' }
  )
);

async function syncOperation(operation: any): Promise<void> {
  const response = await fetch(operation.url, {
    method: operation.method,
    headers: {
      'Content-Type': 'application/json',
    },
    body: operation.data ? JSON.stringify(operation.data) : undefined
  });

  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  return response.json();
}

async function loadServerTasks(): Promise<void> {
  try {
    const response = await fetch('/api/tasks');
    if (response.ok) {
      const serverTasks = await response.json();
      
      // Update the main task store with server data
      const taskStore = useTaskStore.getState();
      taskStore.setTasks(serverTasks);
    }
  } catch (error) {
    console.warn('Failed to load server tasks:', error);
  }
}

// Set up online/offline event listeners
if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    useOfflineTaskStore.getState().setOnlineStatus(true);
  });

  window.addEventListener('offline', () => {
    useOfflineTaskStore.getState().setOnlineStatus(false);
  });

  // Initialize offline storage when store is created
  offlineStorage.initialize().catch(console.error);
  useOfflineTaskStore.getState().loadOfflineTasks().catch(console.error);
}
```

### 4. Offline Indicator Component

Create `components/offline/OfflineIndicator.tsx`:
```typescript
import React, { useState, useEffect } from 'react';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { 
  Popover, 
  PopoverContent, 
  PopoverTrigger 
} from '@/components/ui/popover';
import { useOfflineTaskStore } from '@/lib/stores/offlineTaskStore';
import { 
  Wifi, 
  WifiOff, 
  RefreshCw, 
  Clock, 
  AlertCircle,
  CheckCircle,
  X
} from 'lucide-react';
import { format } from 'date-fns';

export const OfflineIndicator: React.FC = () => {
  const {
    isOnline,
    isSyncing,
    lastSyncTime,
    syncErrors,
    pendingOperations,
    syncTasks,
    clearSyncErrors,
    getPendingSyncCount
  } = useOfflineTaskStore();

  const [isOpen, setIsOpen] = useState(false);
  const pendingCount = getPendingSyncCount();

  const getStatusColor = () => {
    if (!isOnline) return 'bg-red-500';
    if (isSyncing) return 'bg-yellow-500 animate-pulse';
    if (syncErrors.length > 0) return 'bg-orange-500';
    return 'bg-green-500';
  };

  const getStatusText = () => {
    if (!isOnline) return 'Offline';
    if (isSyncing) return 'Syncing...';
    if (syncErrors.length > 0) return `${syncErrors.length} Error${syncErrors.length !== 1 ? 's' : ''}`;
    return 'Online';
  };

  const getStatusIcon = () => {
    if (!isOnline) return <WifiOff className="h-3 w-3" />;
    if (isSyncing) return <RefreshCw className="h-3 w-3 animate-spin" />;
    if (syncErrors.length > 0) return <AlertCircle className="h-3 w-3" />;
    return <Wifi className="h-3 w-3" />;
  };

  const handleSync = async () => {
    if (isOnline && !isSyncing) {
      await syncTasks();
    }
  };

  return (
    <Popover open={isOpen} onOpenChange={setIsOpen}>
      <PopoverTrigger asChild>
        <Button
          variant="ghost"
          size="sm"
          className="flex items-center gap-2 h-8 px-2"
        >
          <div className={`w-2 h-2 rounded-full ${getStatusColor()}`} />
          {getStatusIcon()}
          <span className="text-xs font-medium">{getStatusText()}</span>
          {pendingCount > 0 && (
            <Badge variant="secondary" className="text-xs">
              {pendingCount}
            </Badge>
          )}
        </Button>
      </PopoverTrigger>
      <PopoverContent className="w-80" align="end">
        <div className="space-y-4">
          <div className="flex items-center justify-between">
            <h4 className="font-semibold">Connection Status</h4>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleSync}
              disabled={!isOnline || isSyncing}
              className="h-8 w-8 p-0"
            >
              <RefreshCw className={`h-4 w-4 ${isSyncing ? 'animate-spin' : ''}`} />
            </Button>
          </div>

          <div className="space-y-3">
            {/* Connection Status */}
            <div className="flex items-center gap-2">
              <div className={`w-3 h-3 rounded-full ${getStatusColor()}`} />
              <span className="text-sm font-medium">
                {isOnline ? 'Connected' : 'Offline Mode'}
              </span>
            </div>

            {/* Last Sync Time */}
            {lastSyncTime && (
              <div className="flex items-center gap-2 text-sm text-gray-600">
                <Clock className="h-4 w-4" />
                <span>Last sync: {format(lastSyncTime, 'MMM d, h:mm a')}</span>
              </div>
            )}

            {/* Pending Operations */}
            {pendingCount > 0 && (
              <div className="flex items-center gap-2 text-sm">
                <RefreshCw className="h-4 w-4 text-blue-500" />
                <span>
                  {pendingCount} operation{pendingCount !== 1 ? 's' : ''} pending sync
                </span>
              </div>
            )}

            {/* Sync Errors */}
            {syncErrors.length > 0 && (
              <div className="space-y-2">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium text-red-600">
                    Sync Errors ({syncErrors.length})
                  </span>
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={clearSyncErrors}
                    className="h-6 w-6 p-0"
                  >
                    <X className="h-3 w-3" />
                  </Button>
                </div>
                <div className="space-y-1 max-h-32 overflow-y-auto">
                  {syncErrors.map((error, index) => (
                    <div
                      key={index}
                      className="flex items-start gap-2 p-2 bg-red-50 rounded text-xs text-red-700"
                    >
                      <AlertCircle className="h-3 w-3 mt-0.5 flex-shrink-0" />
                      <span>{error}</span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            {/* Success State */}
            {isOnline && !isSyncing && syncErrors.length === 0 && pendingCount === 0 && (
              <div className="flex items-center gap-2 text-sm text-green-600">
                <CheckCircle className="h-4 w-4" />
                <span>All data synchronized</span>
              </div>
            )}
          </div>

          {/* Offline Mode Info */}
          {!isOnline && (
            <div className="p-3 bg-yellow-50 rounded-md border border-yellow-200">
              <h5 className="text-sm font-semibold text-yellow-800 mb-1">
                Offline Mode
              </h5>
              <p className="text-xs text-yellow-700">
                You can continue working. Changes will sync automatically when you're back online.
              </p>
            </div>
          )}

          {/* Actions */}
          <div className="flex gap-2 pt-2 border-t">
            {isOnline && (
              <Button
                size="sm"
                onClick={handleSync}
                disabled={isSyncing}
                className="flex-1"
              >
                {isSyncing ? 'Syncing...' : 'Sync Now'}
              </Button>
            )}
            <Button
              variant="outline"
              size="sm"
              onClick={() => setIsOpen(false)}
              className="flex-1"
            >
              Close
            </Button>
          </div>
        </div>
      </PopoverContent>
    </Popover>
  );
};
```

### 5. PWA Manifest

Create `public/manifest.json`:
```json
{
  "name": "TaskManager Pro",
  "short_name": "TaskManager",
  "description": "Intelligent task management with focus modes and smart prioritization",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#2563eb",
  "orientation": "portrait-primary",
  "categories": ["productivity", "utilities"],
  "lang": "en-US",
  "scope": "/",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-128x128.png",
      "sizes": "128x128",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-152x152.png",
      "sizes": "152x152",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-384x384.png",
      "sizes": "384x384",
      "type": "image/png",
      "purpose": "maskable any"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "maskable any"
    }
  ],
  "shortcuts": [
    {
      "name": "Add Task",
      "short_name": "Add Task",
      "url": "/?action=add-task",
      "icons": [
        {
          "src": "/icons/shortcut-add.png",
          "sizes": "192x192",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Focus Mode",
      "short_name": "Focus",
      "url": "/?mode=focus",
      "icons": [
        {
          "src": "/icons/shortcut-focus.png",
          "sizes": "192x192",
          "type": "image/png"
        }
      ]
    }
  ],
  "related_applications": [],
  "prefer_related_applications": false,
  "dir": "ltr",
  "serviceworker": {
    "src": "/sw.js",
    "scope": "/",
    "update_via_cache": "none"
  }
}
```

### 6. Service Worker Registration

Create `lib/sw/register.ts`:
```typescript
export interface ServiceWorkerUpdateEvent {
  type: 'update-available' | 'update-installed' | 'offline-ready';
  registration?: ServiceWorkerRegistration;
}

class ServiceWorkerManager {
  private updateCallbacks: ((event: ServiceWorkerUpdateEvent) => void)[] = [];
  private registration: ServiceWorkerRegistration | null = null;

  async register(): Promise<ServiceWorkerRegistration | null> {
    if (!('serviceWorker' in navigator)) {
      console.warn('Service Workers not supported');
      return null;
    }

    try {
      this.registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/',
        updateViaCache: 'none'
      });

      console.log('Service Worker registered successfully');

      // Check for updates
      this.registration.addEventListener('updatefound', () => {
        const newWorker = this.registration!.installing;
        if (newWorker) {
          this.handleServiceWorkerUpdate(newWorker);
        }
      });

      // Handle controller change (new SW took control)
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        this.notifyCallbacks({
          type: 'update-installed',
          registration: this.registration!
        });
      });

      // Check if SW is already controlling the page
      if (navigator.serviceWorker.controller) {
        this.notifyCallbacks({
          type: 'offline-ready',
          registration: this.registration
        });
      }

      // Check for waiting service worker
      if (this.registration.waiting) {
        this.notifyCallbacks({
          type: 'update-available',
          registration: this.registration
        });
      }

      // Check for updates every 60 seconds
      setInterval(() => {
        this.registration?.update();
      }, 60000);

      return this.registration;
    } catch (error) {
      console.error('Service Worker registration failed:', error);
      return null;
    }
  }

  private handleServiceWorkerUpdate(newWorker: ServiceWorker): void {
    newWorker.addEventListener('statechange', () => {
      if (newWorker.state === 'installed') {
        if (navigator.serviceWorker.controller) {
          // Update available
          this.notifyCallbacks({
            type: 'update-available',
            registration: this.registration!
          });
        } else {
          // First install
          this.notifyCallbacks({
            type: 'offline-ready',
            registration: this.registration!
          });
        }
      }
    });
  }

  async skipWaiting(): Promise<void> {
    if (this.registration?.waiting) {
      // Send message to waiting SW to skip waiting
      this.registration.waiting.postMessage({ type: 'SKIP_WAITING' });
    }
  }

  onUpdate(callback: (event: ServiceWorkerUpdateEvent) => void): () => void {
    this.updateCallbacks.push(callback);
    
    // Return unsubscribe function
    return () => {
      const index = this.updateCallbacks.indexOf(callback);
      if (index > -1) {
        this.updateCallbacks.splice(index, 1);
      }
    };
  }

  private notifyCallbacks(event: ServiceWorkerUpdateEvent): void {
    this.updateCallbacks.forEach(callback => callback(event));
  }

  // Send message to service worker
  async sendMessage(message: any): Promise<void> {
    if (navigator.serviceWorker.controller) {
      navigator.serviceWorker.controller.postMessage(message);
    }
  }

  // Queue operation for background sync
  async queueOperation(operation: any): Promise<void> {
    await this.sendMessage({
      type: 'QUEUE_OPERATION',
      payload: operation
    });
  }

  // Trigger background sync
  async triggerSync(tag: string = 'sync-tasks'): Promise<void> {
    if (this.registration && 'sync' in ServiceWorkerRegistration.prototype) {
      try {
        await this.registration.sync.register(tag);
      } catch (error) {
        console.warn('Background sync not available:', error);
      }
    }
  }
}

export const serviceWorkerManager = new ServiceWorkerManager();

// Auto-register when in browser
if (typeof window !== 'undefined') {
  serviceWorkerManager.register();
}
```

### 7. Update Notification Component

Create `components/sw/UpdateNotification.tsx`:
```typescript
import React, { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { serviceWorkerManager, ServiceWorkerUpdateEvent } from '@/lib/sw/register';
import { RefreshCw, Download, X } from 'lucide-react';

export const UpdateNotification: React.FC = () => {
  const [updateEvent, setUpdateEvent] = useState<ServiceWorkerUpdateEvent | null>(null);
  const [isUpdating, setIsUpdating] = useState(false);

  useEffect(() => {
    const unsubscribe = serviceWorkerManager.onUpdate((event) => {
      setUpdateEvent(event);
    });

    return unsubscribe;
  }, []);

  const handleUpdate = async () => {
    setIsUpdating(true);
    
    try {
      await serviceWorkerManager.skipWaiting();
      
      // Reload the page to get the new version
      setTimeout(() => {
        window.location.reload();
      }, 1000);
    } catch (error) {
      console.error('Update failed:', error);
      setIsUpdating(false);
    }
  };

  const handleDismiss = () => {
    setUpdateEvent(null);
  };

  if (!updateEvent || updateEvent.type === 'offline-ready') {
    return null;
  }

  return (
    <Card className="fixed bottom-4 left-4 right-4 z-50 shadow-lg border border-blue-200 bg-blue-50 md:left-auto md:right-4 md:w-96">
      <CardContent className="p-4">
        <div className="flex items-start gap-3">
          <div className="flex-shrink-0 mt-0.5">
            {updateEvent.type === 'update-available' ? (
              <Download className="h-5 w-5 text-blue-600" />
            ) : (
              <RefreshCw className="h-5 w-5 text-green-600" />
            )}
          </div>
          
          <div className="flex-1 min-w-0">
            <h4 className="font-semibold text-gray-900 text-sm">
              {updateEvent.type === 'update-available' 
                ? 'Update Available' 
                : 'Update Ready'}
            </h4>
            <p className="text-sm text-gray-600 mt-1">
              {updateEvent.type === 'update-available'
                ? 'A new version of the app is available with the latest features and improvements.'
                : 'The app has been updated and is ready to restart.'}
            </p>
            
            <div className="flex items-center gap-2 mt-3">
              <Button
                size="sm"
                onClick={handleUpdate}
                disabled={isUpdating}
                className="flex items-center gap-1"
              >
                {isUpdating ? (
                  <>
                    <RefreshCw className="h-3 w-3 animate-spin" />
                    Updating...
                  </>
                ) : (
                  <>
                    <RefreshCw className="h-3 w-3" />
                    Update Now
                  </>
                )}
              </Button>
              
              <Button
                variant="ghost"
                size="sm"
                onClick={handleDismiss}
                disabled={isUpdating}
              >
                Later
              </Button>
            </div>
          </div>
          
          <Button
            variant="ghost"
            size="sm"
            onClick={handleDismiss}
            disabled={isUpdating}
            className="flex-shrink-0 h-6 w-6 p-0"
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};
```

### 8. Offline Page

Create `app/offline/page.tsx`:
```typescript
import React from 'react';
import { WifiOff, RefreshCw, Home, ArrowLeft } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export default function OfflinePage() {
  const handleRetry = () => {
    if (navigator.onLine) {
      window.location.reload();
    } else {
      // Show a message that they're still offline
      alert('You\'re still offline. Please check your internet connection.');
    }
  };

  const handleGoHome = () => {
    window.location.href = '/';
  };

  const handleGoBack = () => {
    if (window.history.length > 1) {
      window.history.back();
    } else {
      handleGoHome();
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center p-4">
      <Card className="w-full max-w-md">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 w-16 h-16 bg-gray-100 rounded-full flex items-center justify-center">
            <WifiOff className="h-8 w-8 text-gray-400" />
          </div>
          <CardTitle className="text-xl font-semibold text-gray-900">
            You're Offline
          </CardTitle>
        </CardHeader>
        <CardContent className="text-center space-y-4">
          <p className="text-gray-600">
            It looks like you've lost your internet connection. Don't worry - you can still use the app with limited functionality.
          </p>
          
          <div className="space-y-3">
            <div className="p-3 bg-blue-50 rounded-lg text-left">
              <h4 className="font-medium text-blue-900 mb-1">What you can do:</h4>
              <ul className="text-sm text-blue-700 space-y-1">
                <li>• View existing tasks</li>
                <li>• Create new tasks</li>
                <li>• Edit and complete tasks</li>
                <li>• Use focus modes</li>
              </ul>
            </div>
            
            <div className="p-3 bg-yellow-50 rounded-lg text-left">
              <h4 className="font-medium text-yellow-900 mb-1">Sync when online:</h4>
              <p className="text-sm text-yellow-700">
                All your changes will be saved and synced automatically when you're back online.
              </p>
            </div>
          </div>
          
          <div className="flex flex-col gap-2 pt-4">
            <Button onClick={handleRetry} className="w-full">
              <RefreshCw className="h-4 w-4 mr-2" />
              Try Again
            </Button>
            
            <div className="flex gap-2">
              <Button 
                variant="outline" 
                onClick={handleGoBack}
                className="flex-1"
              >
                <ArrowLeft className="h-4 w-4 mr-2" />
                Go Back
              </Button>
              
              <Button 
                variant="outline" 
                onClick={handleGoHome}
                className="flex-1"
              >
                <Home className="h-4 w-4 mr-2" />
                Home
              </Button>
            </div>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### 9. Enhanced Task API with Conflict Resolution

Create `app/api/tasks/sync/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

interface ConflictResolution {
  strategy: 'client-wins' | 'server-wins' | 'merge' | 'manual';
  resolvedData?: any;
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { operations } = await request.json();
    const results = [];

    for (const operation of operations) {
      try {
        const result = await processOperation(supabase, user.id, operation);
        results.push({
          id: operation.id,
          status: 'success',
          data: result
        });
      } catch (error) {
        results.push({
          id: operation.id,
          status: 'error',
          error: error.message
        });
      }
    }

    return NextResponse.json({ results });
  } catch (error) {
    return NextResponse.json({ error: 'Sync failed' }, { status: 500 });
  }
}

async function processOperation(supabase: any, userId: string, operation: any) {
  const { type, entity, data, clientTimestamp } = operation;

  if (entity === 'task') {
    switch (type) {
      case 'create':
        return await handleCreateTask(supabase, userId, data);
      case 'update':
        return await handleUpdateTask(supabase, userId, data, clientTimestamp);
      case 'delete':
        return await handleDeleteTask(supabase, userId, data.id);
      default:
        throw new Error(`Unknown operation type: ${type}`);
    }
  }

  throw new Error(`Unknown entity type: ${entity}`);
}

async function handleCreateTask(supabase: any, userId: string, taskData: any) {
  // Check if task already exists (idempotency)
  const { data: existing } = await supabase
    .from('tasks')
    .select('id')
    .eq('id', taskData.id)
    .eq('user_id', userId)
    .single();

  if (existing) {
    return existing; // Already exists, return existing
  }

  const { data: task, error } = await supabase
    .from('tasks')
    .insert({
      ...taskData,
      user_id: userId,
      created_at: new Date().toISOString(),
      updated_at: new Date().toISOString()
    })
    .select()
    .single();

  if (error) throw new Error(error.message);
  return task;
}

async function handleUpdateTask(
  supabase: any, 
  userId: string, 
  taskData: any, 
  clientTimestamp: string
) {
  // Get current server version
  const { data: serverTask, error: fetchError } = await supabase
    .from('tasks')
    .select('*')
    .eq('id', taskData.id)
    .eq('user_id', userId)
    .single();

  if (fetchError) throw new Error(fetchError.message);

  // Check for conflicts
  const serverUpdateTime = new Date(serverTask.updated_at);
  const clientUpdateTime = new Date(clientTimestamp);

  if (serverUpdateTime > clientUpdateTime) {
    // Conflict detected - server has newer version
    const resolution = resolveConflict(serverTask, taskData, 'client-wins'); // Default strategy
    
    if (resolution.strategy === 'server-wins') {
      return serverTask;
    }
    
    const dataToUpdate = resolution.resolvedData || taskData;
    
    const { data: updated, error } = await supabase
      .from('tasks')
      .update({
        ...dataToUpdate,
        updated_at: new Date().toISOString(),
        conflict_resolved_at: new Date().toISOString()
      })
      .eq('id', taskData.id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw new Error(error.message);
    return updated;
  } else {
    // No conflict, normal update
    const { data: updated, error } = await supabase
      .from('tasks')
      .update({
        ...taskData,
        updated_at: new Date().toISOString()
      })
      .eq('id', taskData.id)
      .eq('user_id', userId)
      .select()
      .single();

    if (error) throw new Error(error.message);
    return updated;
  }
}

async function handleDeleteTask(supabase: any, userId: string, taskId: string) {
  const { error } = await supabase
    .from('tasks')
    .delete()
    .eq('id', taskId)
    .eq('user_id', userId);

  if (error) throw new Error(error.message);
  return { id: taskId, deleted: true };
}

function resolveConflict(serverData: any, clientData: any, strategy: string): ConflictResolution {
  switch (strategy) {
    case 'client-wins':
      return { strategy: 'client-wins', resolvedData: clientData };
    
    case 'server-wins':
      return { strategy: 'server-wins', resolvedData: serverData };
    
    case 'merge':
      // Simple merge strategy - prefer client data but keep server timestamps
      const merged = {
        ...serverData,
        ...clientData,
        created_at: serverData.created_at,
        updated_at: serverData.updated_at
      };
      return { strategy: 'merge', resolvedData: merged };
    
    default:
      return { strategy: 'client-wins', resolvedData: clientData };
  }
}
```

### 10. Background Sync Hook

Create `lib/hooks/useBackgroundSync.ts`:
```typescript
import { useEffect, useCallback } from 'react';
import { useOfflineTaskStore } from '../stores/offlineTaskStore';
import { serviceWorkerManager } from '../sw/register';

export function useBackgroundSync() {
  const { isOnline, isSyncing, syncTasks, setOnlineStatus } = useOfflineTaskStore();

  // Monitor online/offline status
  useEffect(() => {
    const handleOnline = () => {
      setOnlineStatus(true);
      // Auto-sync after coming online with a delay
      setTimeout(syncTasks, 2000);
    };

    const handleOffline = () => {
      setOnlineStatus(false);
    };

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    // Set initial status
    setOnlineStatus(navigator.onLine);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [setOnlineStatus, syncTasks]);

  // Periodic sync when online
  useEffect(() => {
    if (!isOnline || isSyncing) return;

    const interval = setInterval(() => {
      if (navigator.onLine && !document.hidden) {
        syncTasks();
      }
    }, 5 * 60 * 1000); // Sync every 5 minutes

    return () => clearInterval(interval);
  }, [isOnline, isSyncing, syncTasks]);

  // Visibility change sync
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (!document.hidden && isOnline && !isSyncing) {
        // Sync when page becomes visible
        syncTasks();
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
  }, [isOnline, isSyncing, syncTasks]);

  const triggerBackgroundSync = useCallback(async (tag: string = 'sync-tasks') => {
    if ('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) {
      try {
        await serviceWorkerManager.triggerSync(tag);
      } catch (error) {
        console.warn('Background sync failed:', error);
        // Fallback to immediate sync
        if (isOnline) {
          syncTasks();
        }
      }
    } else {
      // Fallback for browsers without background sync
      if (isOnline) {
        syncTasks();
      }
    }
  }, [isOnline, syncTasks]);

  return {
    isOnline,
    isSyncing,
    triggerBackgroundSync,
    manualSync: syncTasks
  };
}
```

### 11. Next.js Configuration Updates

Update `next.config.js`:
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true
  },
  
  // PWA Configuration
  async rewrites() {
    return [
      {
        source: '/sw.js',
        destination: '/_next/static/sw.js'
      }
    ];
  },
  
  async headers() {
    return [
      {
        source: '/sw.js',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-cache, no-store, must-revalidate'
          },
          {
            key: 'Service-Worker-Allowed',
            value: '/'
          }
        ]
      },
      {
        source: '/manifest.json',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable'
          }
        ]
      }
    ];
  },

  // Enable static optimization
  output: 'standalone',
  
  // Image optimization
  images: {
    domains: ['localhost'],
    formats: ['image/webp', 'image/avif']
  },

  // Compression
  compress: true,

  // Security headers
  poweredByHeader: false
};

module.exports = nextConfig;
```

### 12. Testing Strategy

**Unit Tests (`__tests__/offline/`):**
```typescript
// storage.test.ts
describe('OfflineStorageManager', () => {
  let storage: OfflineStorageManager;
  
  beforeEach(async () => {
    storage = new OfflineStorageManager();
    await storage.initialize();
  });

  test('should store and retrieve data', async () => {
    const testData = { id: '1', title: 'Test Task' };
    await storage.storeData('task_1', 'task', testData);
    
    const retrieved = await storage.getData('task_1');
    expect(retrieved).toEqual(testData);
  });

  test('should queue operations for sync', async () => {
    const operation = {
      type: 'create' as const,
      entity: 'task' as const,
      data: { title: 'New Task' },
      url: '/api/tasks',
      method: 'POST'
    };
    
    await storage.queueOperation(operation);
    
    const pending = await storage.getPendingOperations();
    expect(pending).toHaveLength(1);
    expect(pending[0].type).toBe('create');
  });
});

// serviceWorker.test.ts
describe('Service Worker', () => {
  test('should cache static assets', async () => {
    // Mock service worker testing
    const mockCaches = {
      open: jest.fn().mockResolvedValue({
        addAll: jest.fn().mockResolvedValue(undefined)
      })
    };
    global.caches = mockCaches as any;

    // Test caching functionality
    // This would require a more sophisticated setup with service worker testing tools
  });
});
```

**Integration Tests:**
```typescript
// offline.integration.test.ts
describe('Offline Integration', () => {
  test('should create tasks offline and sync when online', async () => {
    // Set offline state
    Object.defineProperty(navigator, 'onLine', {
      writable: true,
      value: false
    });

    const store = useOfflineTaskStore.getState();
    
    // Create task offline
    const task = await store.createOfflineTask({
      title: 'Offline Task',
      description: 'Created while offline'
    });
    
    expect(task.isOffline).toBe(true);
    
    // Simulate going online
    Object.defineProperty(navigator, 'onLine', {
      value: true
    });
    
    store.setOnlineStatus(true);
    
    // Mock successful sync
    jest.spyOn(window, 'fetch').mockResolvedValueOnce({
      ok: true,
      json: () => Promise.resolve({ ...task, isOffline: false })
    } as Response);
    
    await store.syncTasks();
    
    // Verify task was synced
    expect(fetch).toHaveBeenCalledWith('/api/tasks', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(task)
    });
  });
});
```

**E2E Tests:**
```typescript
// offline.e2e.test.ts
describe('Offline E2E', () => {
  test('should work offline and sync when online', async () => {
    // Use Playwright or Cypress to test offline scenarios
    await page.setOfflineMode(true);
    
    // Create tasks while offline
    await page.fill('[data-testid="task-title"]', 'Offline Task');
    await page.click('[data-testid="add-task"]');
    
    // Verify task appears in UI
    await expect(page.locator('[data-testid="task-item"]')).toContainText('Offline Task');
    
    // Go back online
    await page.setOfflineMode(false);
    
    // Verify sync occurs
    await page.waitForSelector('[data-testid="sync-indicator"][data-status="synced"]');
  });
});
```

## Dependencies
- [ ] Tasks 004-007 completed (Core functionality)
- [ ] API endpoints support idempotent operations

## Effort Estimate
- Size: L
- Hours: 6
- Parallel: true

## Definition of Done
- [ ] Service Worker functioning
- [ ] Offline mode tested thoroughly
- [ ] Sync queue working reliably
- [ ] PWA installable
- [ ] Performance metrics met
