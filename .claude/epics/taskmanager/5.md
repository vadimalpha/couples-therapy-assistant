---
name: Task CRUD Operations
status: open
created: 2025-08-26T18:29:07Z
updated: 2025-08-26T20:52:21Z
github: https://github.com/vadimalpha/taskmanager/issues/5
depends_on: [003]
parallel: false
conflicts_with: []
---

# Task: Task CRUD Operations

## Description
Implement comprehensive task management functionality with create, read, update, and delete operations using React Query for optimistic updates, real-time subscriptions, and Supabase for persistence. Include advanced features like drag-and-drop reordering, batch operations, and inline editing.

## Detailed Implementation Specification

### 1. Task Data Layer - Types and Interfaces

#### Update `types/task.ts`:
```typescript
import { Database } from './database'

export type Task = Database['public']['Tables']['tasks']['Row']
export type TaskInsert = Database['public']['Tables']['tasks']['Insert']
export type TaskUpdate = Database['public']['Tables']['tasks']['Update']

export type TaskPriority = 'low' | 'medium' | 'high' | 'urgent'
export type TaskStatus = 'todo' | 'in_progress' | 'completed' | 'archived'
export type TaskQuadrant = 'urgent_important' | 'not_urgent_important' | 'urgent_not_important' | 'not_urgent_not_important'

export interface TaskFormData {
  title: string
  description?: string
  priority: TaskPriority
  due_date?: string
  scheduled_date?: string
  project_id?: string
  tags: string[]
  context?: string
  energy_level?: string
  estimated_minutes?: number
}

export interface TaskFilter {
  status?: TaskStatus[]
  priority?: TaskPriority[]
  project_id?: string
  tags?: string[]
  context?: string
  due_date_range?: {
    from?: string
    to?: string
  }
  search?: string
}

export interface TaskSort {
  field: 'created_at' | 'updated_at' | 'due_date' | 'priority' | 'title'
  direction: 'asc' | 'desc'
}

// Extended task with computed properties
export interface ExtendedTask extends Task {
  project?: {
    id: string
    name: string
    color: string
    icon?: string
  }
  overdue: boolean
  dueToday: boolean
  dueSoon: boolean
  isSelected?: boolean
  subtasks?: ExtendedTask[]
}

export interface TaskBatchOperation {
  type: 'update' | 'delete' | 'move'
  taskIds: string[]
  data?: Partial<TaskUpdate>
}
```

### 2. Task Store with Zustand

#### Create `stores/taskStore.ts`:
```typescript
import { create } from 'zustand'
import { devtools, subscribeWithSelector } from 'zustand/middleware'
import { ExtendedTask, TaskFilter, TaskSort } from '@/types/task'

interface TaskState {
  // UI State
  selectedTaskIds: string[]
  isCreating: boolean
  isEditing: string | null
  viewMode: 'list' | 'kanban' | 'calendar'
  showCompleted: boolean
  
  // Filters and sorting
  filters: TaskFilter
  sort: TaskSort
  searchQuery: string
  
  // Optimistic updates
  optimisticTasks: Map<string, ExtendedTask>
  undoStack: Array<{ action: string; data: any }>
  
  // Actions
  setSelectedTasks: (taskIds: string[]) => void
  toggleTaskSelection: (taskId: string) => void
  clearSelection: () => void
  setCreating: (isCreating: boolean) => void
  setEditing: (taskId: string | null) => void
  setViewMode: (mode: 'list' | 'kanban' | 'calendar') => void
  setShowCompleted: (show: boolean) => void
  setFilters: (filters: Partial<TaskFilter>) => void
  setSort: (sort: TaskSort) => void
  setSearchQuery: (query: string) => void
  addOptimisticTask: (task: ExtendedTask) => void
  updateOptimisticTask: (taskId: string, updates: Partial<ExtendedTask>) => void
  removeOptimisticTask: (taskId: string) => void
  clearOptimisticTasks: () => void
  pushUndo: (action: string, data: any) => void
  popUndo: () => { action: string; data: any } | undefined
}

export const useTaskStore = create<TaskState>()(
  devtools(
    subscribeWithSelector((set, get) => ({
      // Initial state
      selectedTaskIds: [],
      isCreating: false,
      isEditing: null,
      viewMode: 'list',
      showCompleted: false,
      filters: {},
      sort: { field: 'created_at', direction: 'desc' },
      searchQuery: '',
      optimisticTasks: new Map(),
      undoStack: [],
      
      // Actions
      setSelectedTasks: (taskIds) => set({ selectedTaskIds: taskIds }),
      
      toggleTaskSelection: (taskId) => set((state) => ({
        selectedTaskIds: state.selectedTaskIds.includes(taskId)
          ? state.selectedTaskIds.filter(id => id !== taskId)
          : [...state.selectedTaskIds, taskId]
      })),
      
      clearSelection: () => set({ selectedTaskIds: [] }),
      
      setCreating: (isCreating) => set({ isCreating }),
      
      setEditing: (taskId) => set({ isEditing: taskId }),
      
      setViewMode: (mode) => set({ viewMode: mode }),
      
      setShowCompleted: (show) => set({ showCompleted: show }),
      
      setFilters: (filters) => set((state) => ({
        filters: { ...state.filters, ...filters }
      })),
      
      setSort: (sort) => set({ sort }),
      
      setSearchQuery: (query) => set({ searchQuery: query }),
      
      addOptimisticTask: (task) => set((state) => {
        const newMap = new Map(state.optimisticTasks)
        newMap.set(task.id, task)
        return { optimisticTasks: newMap }
      }),
      
      updateOptimisticTask: (taskId, updates) => set((state) => {
        const newMap = new Map(state.optimisticTasks)
        const existing = newMap.get(taskId)
        if (existing) {
          newMap.set(taskId, { ...existing, ...updates })
        }
        return { optimisticTasks: newMap }
      }),
      
      removeOptimisticTask: (taskId) => set((state) => {
        const newMap = new Map(state.optimisticTasks)
        newMap.delete(taskId)
        return { optimisticTasks: newMap }
      }),
      
      clearOptimisticTasks: () => set({ optimisticTasks: new Map() }),
      
      pushUndo: (action, data) => set((state) => ({
        undoStack: [...state.undoStack.slice(-9), { action, data }] // Keep last 10 actions
      })),
      
      popUndo: () => {
        const state = get()
        if (state.undoStack.length === 0) return undefined
        
        const lastAction = state.undoStack[state.undoStack.length - 1]
        set({ undoStack: state.undoStack.slice(0, -1) })
        return lastAction
      }
    })),
    { name: 'TaskStore' }
  )
)
```

### 3. Task API Service

#### Create `lib/api/tasks.ts`:
```typescript
import { createClient } from '@/lib/supabase/client'
import { Task, TaskInsert, TaskUpdate, ExtendedTask, TaskFilter, TaskSort } from '@/types/task'

const supabase = createClient()

export class TaskAPI {
  // Create a new task
  static async create(taskData: TaskInsert): Promise<ExtendedTask> {
    const { data, error } = await supabase
      .from('tasks')
      .insert([taskData])
      .select(`
        *,
        project:projects(id, name, color, icon)
      `)
      .single()

    if (error) throw error
    return this.enhanceTask(data as any)
  }

  // Get tasks with filters and sorting
  static async getAll(
    userId: string,
    filters: TaskFilter = {},
    sort: TaskSort = { field: 'created_at', direction: 'desc' },
    limit?: number
  ): Promise<ExtendedTask[]> {
    let query = supabase
      .from('tasks')
      .select(`
        *,
        project:projects(id, name, color, icon)
      `)
      .eq('user_id', userId)

    // Apply filters
    if (filters.status?.length) {
      query = query.in('status', filters.status)
    }
    
    if (filters.priority?.length) {
      query = query.in('priority', filters.priority)
    }
    
    if (filters.project_id) {
      query = query.eq('project_id', filters.project_id)
    }
    
    if (filters.context) {
      query = query.eq('context', filters.context)
    }
    
    if (filters.due_date_range?.from) {
      query = query.gte('due_date', filters.due_date_range.from)
    }
    
    if (filters.due_date_range?.to) {
      query = query.lte('due_date', filters.due_date_range.to)
    }
    
    if (filters.tags?.length) {
      query = query.overlaps('tags', filters.tags)
    }
    
    if (filters.search) {
      query = query.or(`title.ilike.%${filters.search}%,description.ilike.%${filters.search}%`)
    }

    // Apply sorting
    const ascending = sort.direction === 'asc'
    query = query.order(sort.field, { ascending })

    // Apply limit
    if (limit) {
      query = query.limit(limit)
    }

    const { data, error } = await query

    if (error) throw error
    return (data as any[])?.map(this.enhanceTask) || []
  }

  // Get single task by ID
  static async getById(taskId: string): Promise<ExtendedTask> {
    const { data, error } = await supabase
      .from('tasks')
      .select(`
        *,
        project:projects(id, name, color, icon)
      `)
      .eq('id', taskId)
      .single()

    if (error) throw error
    return this.enhanceTask(data as any)
  }

  // Update task
  static async update(taskId: string, updates: TaskUpdate): Promise<ExtendedTask> {
    const { data, error } = await supabase
      .from('tasks')
      .update(updates)
      .eq('id', taskId)
      .select(`
        *,
        project:projects(id, name, color, icon)
      `)
      .single()

    if (error) throw error
    return this.enhanceTask(data as any)
  }

  // Batch update tasks
  static async batchUpdate(taskIds: string[], updates: TaskUpdate): Promise<ExtendedTask[]> {
    const { data, error } = await supabase
      .from('tasks')
      .update(updates)
      .in('id', taskIds)
      .select(`
        *,
        project:projects(id, name, color, icon)
      `)

    if (error) throw error
    return (data as any[])?.map(this.enhanceTask) || []
  }

  // Delete task
  static async delete(taskId: string): Promise<void> {
    const { error } = await supabase
      .from('tasks')
      .delete()
      .eq('id', taskId)

    if (error) throw error
  }

  // Batch delete tasks
  static async batchDelete(taskIds: string[]): Promise<void> {
    const { error } = await supabase
      .from('tasks')
      .delete()
      .in('id', taskIds)

    if (error) throw error
  }

  // Get today's priority tasks using database function
  static async getTodaysTasks(userId: string, limit: number = 5): Promise<ExtendedTask[]> {
    const { data, error } = await supabase
      .rpc('get_todays_tasks', {
        p_user_id: userId,
        p_limit: limit
      })

    if (error) throw error
    return (data || []).map((task: any) => ({
      ...task,
      project: task.project_id ? {
        id: task.project_id,
        name: task.project_name,
        color: task.project_color,
      } : undefined,
      overdue: new Date(task.due_date) < new Date(),
      dueToday: this.isDueToday(task.due_date),
      dueSoon: this.isDueSoon(task.due_date),
    }))
  }

  // Subscribe to real-time changes
  static subscribeToChanges(
    userId: string,
    onInsert: (task: Task) => void,
    onUpdate: (task: Task) => void,
    onDelete: (taskId: string) => void
  ) {
    return supabase
      .channel('tasks')
      .on(
        'postgres_changes',
        {
          event: 'INSERT',
          schema: 'public',
          table: 'tasks',
          filter: `user_id=eq.${userId}`,
        },
        (payload) => onInsert(payload.new as Task)
      )
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'tasks',
          filter: `user_id=eq.${userId}`,
        },
        (payload) => onUpdate(payload.new as Task)
      )
      .on(
        'postgres_changes',
        {
          event: 'DELETE',
          schema: 'public',
          table: 'tasks',
          filter: `user_id=eq.${userId}`,
        },
        (payload) => onDelete(payload.old.id)
      )
      .subscribe()
  }

  // Helper method to enhance tasks with computed properties
  private static enhanceTask(task: any): ExtendedTask {
    return {
      ...task,
      overdue: task.due_date ? new Date(task.due_date) < new Date() : false,
      dueToday: this.isDueToday(task.due_date),
      dueSoon: this.isDueSoon(task.due_date),
    }
  }

  private static isDueToday(dueDate: string | null): boolean {
    if (!dueDate) return false
    const today = new Date()
    const due = new Date(dueDate)
    return today.toDateString() === due.toDateString()
  }

  private static isDueSoon(dueDate: string | null): boolean {
    if (!dueDate) return false
    const today = new Date()
    const due = new Date(dueDate)
    const diffTime = due.getTime() - today.getTime()
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24))
    return diffDays >= 0 && diffDays <= 3
  }
}
```

### 4. React Query Hooks for Tasks

#### Create `hooks/useTasks.ts`:
```typescript
import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query'
import { useAuth } from './useAuth'
import { TaskAPI } from '@/lib/api/tasks'
import { TaskInsert, TaskUpdate, ExtendedTask, TaskFilter, TaskSort, TaskBatchOperation } from '@/types/task'
import { useTaskStore } from '@/stores/taskStore'
import { toast } from 'sonner'
import { useEffect, useCallback } from 'react'

// Query keys
export const taskKeys = {
  all: ['tasks'] as const,
  lists: () => [...taskKeys.all, 'list'] as const,
  list: (filters: TaskFilter, sort: TaskSort) => [...taskKeys.lists(), { filters, sort }] as const,
  details: () => [...taskKeys.all, 'detail'] as const,
  detail: (id: string) => [...taskKeys.details(), id] as const,
  todays: (userId: string) => [...taskKeys.all, 'todays', userId] as const,
}

// Get tasks with filters and sorting
export function useTasks(
  filters: TaskFilter = {},
  sort: TaskSort = { field: 'created_at', direction: 'desc' },
  limit?: number
) {
  const { user } = useAuth()
  const { optimisticTasks, clearOptimisticTasks } = useTaskStore()

  const query = useQuery({
    queryKey: taskKeys.list(filters, sort),
    queryFn: () => TaskAPI.getAll(user!.id, filters, sort, limit),
    enabled: !!user?.id,
    staleTime: 1000 * 60 * 5, // 5 minutes
  })

  // Merge optimistic updates with real data
  const tasksWithOptimistic = query.data ? 
    query.data.map(task => {
      const optimistic = optimisticTasks.get(task.id)
      return optimistic ? { ...task, ...optimistic } : task
    }) : []

  return {
    ...query,
    data: tasksWithOptimistic,
  }
}

// Get single task
export function useTask(taskId: string) {
  const { optimisticTasks } = useTaskStore()

  const query = useQuery({
    queryKey: taskKeys.detail(taskId),
    queryFn: () => TaskAPI.getById(taskId),
    enabled: !!taskId,
  })

  // Apply optimistic updates
  const taskWithOptimistic = query.data && optimisticTasks.has(taskId)
    ? { ...query.data, ...optimisticTasks.get(taskId) }
    : query.data

  return {
    ...query,
    data: taskWithOptimistic,
  }
}

// Get today's priority tasks
export function useTodaysTasks(limit: number = 5) {
  const { user } = useAuth()

  return useQuery({
    queryKey: taskKeys.todays(user?.id || ''),
    queryFn: () => TaskAPI.getTodaysTasks(user!.id, limit),
    enabled: !!user?.id,
    staleTime: 1000 * 60 * 2, // 2 minutes
  })
}

// Create task mutation
export function useCreateTask() {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const { addOptimisticTask, removeOptimisticTask, pushUndo } = useTaskStore()

  return useMutation({
    mutationFn: (taskData: TaskInsert) => {
      // Add user_id to task data
      return TaskAPI.create({ ...taskData, user_id: user!.id })
    },
    
    onMutate: async (taskData) => {
      // Create optimistic task
      const optimisticTask: ExtendedTask = {
        id: `temp-${Date.now()}`,
        user_id: user!.id,
        title: taskData.title,
        description: taskData.description || '',
        status: taskData.status || 'todo',
        priority: taskData.priority || 'medium',
        due_date: taskData.due_date || null,
        scheduled_date: taskData.scheduled_date || null,
        project_id: taskData.project_id || null,
        tags: taskData.tags || [],
        context: taskData.context || null,
        energy_level: taskData.energy_level || null,
        estimated_minutes: taskData.estimated_minutes || null,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
        completed_at: null,
        actual_minutes: null,
        focus_time: null,
        interruption_count: 0,
        is_recurring: false,
        recurring_config: null,
        parent_task_id: null,
        subtask_count: 0,
        attachment_count: 0,
        ai_suggested_date: null,
        ai_priority_score: null,
        auto_scheduled: false,
        quadrant: null,
        overdue: false,
        dueToday: false,
        dueSoon: false,
      }

      addOptimisticTask(optimisticTask)

      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: taskKeys.lists() })

      return { optimisticTask }
    },

    onSuccess: (newTask, _, context) => {
      // Remove optimistic task
      if (context?.optimisticTask) {
        removeOptimisticTask(context.optimisticTask.id)
      }

      // Update cache with real task
      queryClient.invalidateQueries({ queryKey: taskKeys.lists() })
      queryClient.setQueryData(taskKeys.detail(newTask.id), newTask)

      toast.success('Task created successfully')
    },

    onError: (error, _, context) => {
      // Remove optimistic task on error
      if (context?.optimisticTask) {
        removeOptimisticTask(context.optimisticTask.id)
      }

      console.error('Failed to create task:', error)
      toast.error('Failed to create task')
    },
  })
}

// Update task mutation
export function useUpdateTask() {
  const queryClient = useQueryClient()
  const { updateOptimisticTask, removeOptimisticTask, pushUndo } = useTaskStore()

  return useMutation({
    mutationFn: ({ taskId, updates }: { taskId: string; updates: TaskUpdate }) => 
      TaskAPI.update(taskId, updates),

    onMutate: async ({ taskId, updates }) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: taskKeys.detail(taskId) })

      // Get previous task data for undo
      const previousTask = queryClient.getQueryData(taskKeys.detail(taskId))
      
      // Apply optimistic update
      updateOptimisticTask(taskId, updates)

      // Store undo data
      pushUndo('update', { taskId, previousData: previousTask, newData: updates })

      return { previousTask, taskId }
    },

    onSuccess: (updatedTask, { taskId }) => {
      // Remove optimistic update
      removeOptimisticTask(taskId)

      // Update cache with real data
      queryClient.setQueryData(taskKeys.detail(taskId), updatedTask)
      queryClient.invalidateQueries({ queryKey: taskKeys.lists() })

      toast.success('Task updated successfully')
    },

    onError: (error, { taskId }, context) => {
      // Revert optimistic update
      removeOptimisticTask(taskId)

      // Restore previous data
      if (context?.previousTask) {
        queryClient.setQueryData(taskKeys.detail(taskId), context.previousTask)
      }

      console.error('Failed to update task:', error)
      toast.error('Failed to update task')
    },
  })
}

// Delete task mutation
export function useDeleteTask() {
  const queryClient = useQueryClient()
  const { removeOptimisticTask, pushUndo } = useTaskStore()

  return useMutation({
    mutationFn: (taskId: string) => TaskAPI.delete(taskId),

    onMutate: async (taskId) => {
      // Cancel outgoing refetches
      await queryClient.cancelQueries({ queryKey: taskKeys.detail(taskId) })

      // Get previous task data for undo
      const previousTask = queryClient.getQueryData(taskKeys.detail(taskId))

      // Optimistically remove task
      removeOptimisticTask(taskId)
      queryClient.removeQueries({ queryKey: taskKeys.detail(taskId) })

      // Store undo data
      pushUndo('delete', { taskId, previousData: previousTask })

      return { previousTask, taskId }
    },

    onSuccess: (_, taskId) => {
      // Invalidate lists to remove deleted task
      queryClient.invalidateQueries({ queryKey: taskKeys.lists() })
      
      toast.success('Task deleted successfully')
    },

    onError: (error, taskId, context) => {
      // Restore previous data
      if (context?.previousTask) {
        queryClient.setQueryData(taskKeys.detail(taskId), context.previousTask)
      }

      queryClient.invalidateQueries({ queryKey: taskKeys.lists() })

      console.error('Failed to delete task:', error)
      toast.error('Failed to delete task')
    },
  })
}

// Batch operations mutation
export function useBatchOperations() {
  const queryClient = useQueryClient()
  const { clearSelection, pushUndo } = useTaskStore()

  return useMutation({
    mutationFn: async ({ type, taskIds, data }: TaskBatchOperation) => {
      switch (type) {
        case 'update':
          return TaskAPI.batchUpdate(taskIds, data!)
        case 'delete':
          await TaskAPI.batchDelete(taskIds)
          return taskIds
        default:
          throw new Error(`Unsupported batch operation: ${type}`)
      }
    },

    onSuccess: (result, { type, taskIds }) => {
      // Clear selection
      clearSelection()

      // Invalidate relevant queries
      queryClient.invalidateQueries({ queryKey: taskKeys.lists() })

      // Show success message
      const message = type === 'delete' 
        ? `${taskIds.length} tasks deleted`
        : `${taskIds.length} tasks updated`
      
      toast.success(message)
    },

    onError: (error, { type }) => {
      console.error(`Batch ${type} failed:`, error)
      toast.error(`Batch operation failed`)
    },
  })
}

// Real-time subscription hook
export function useTaskSubscription() {
  const { user } = useAuth()
  const queryClient = useQueryClient()

  useEffect(() => {
    if (!user?.id) return

    const channel = TaskAPI.subscribeToChanges(
      user.id,
      // On insert
      (newTask) => {
        queryClient.invalidateQueries({ queryKey: taskKeys.lists() })
      },
      // On update
      (updatedTask) => {
        queryClient.setQueryData(taskKeys.detail(updatedTask.id), updatedTask)
        queryClient.invalidateQueries({ queryKey: taskKeys.lists() })
      },
      // On delete
      (taskId) => {
        queryClient.removeQueries({ queryKey: taskKeys.detail(taskId) })
        queryClient.invalidateQueries({ queryKey: taskKeys.lists() })
      }
    )

    return () => {
      supabase.removeChannel(channel)
    }
  }, [user?.id, queryClient])
}

// Undo/Redo functionality
export function useTaskUndo() {
  const { popUndo } = useTaskStore()
  const updateTask = useUpdateTask()
  const createTask = useCreateTask()

  const undo = useCallback(async () => {
    const lastAction = popUndo()
    if (!lastAction) return

    switch (lastAction.action) {
      case 'update':
        const { taskId, previousData } = lastAction.data
        if (previousData) {
          updateTask.mutate({ taskId, updates: previousData })
        }
        break
      
      case 'delete':
        const { previousData: taskData } = lastAction.data
        if (taskData) {
          const { id, ...insertData } = taskData
          createTask.mutate(insertData)
        }
        break
    }
  }, [popUndo, updateTask, createTask])

  return { undo, canUndo: useTaskStore(state => state.undoStack.length > 0) }
}
```

### 5. Task Components

#### Create `components/tasks/TaskList.tsx`:
```typescript
'use client'

import { useState } from 'react'
import { ExtendedTask, TaskFilter, TaskSort } from '@/types/task'
import { TaskItem } from './TaskItem'
import { TaskForm } from './TaskForm'
import { TaskFilters } from './TaskFilters'
import { TaskBatchActions } from './TaskBatchActions'
import { useTasks } from '@/hooks/useTasks'
import { useTaskStore } from '@/stores/taskStore'
import { Button } from '@/components/ui/button'
import { Card, CardContent } from '@/components/ui/card'
import { Skeleton } from '@/components/ui/skeleton'
import { Plus, Filter, MoreHorizontal } from 'lucide-react'
import { DragDropContext, Droppable, Draggable, DropResult } from 'react-beautiful-dnd'

interface TaskListProps {
  showFilters?: boolean
  showBatchActions?: boolean
  enableDragDrop?: boolean
  limit?: number
  className?: string
}

export function TaskList({ 
  showFilters = true,
  showBatchActions = true,
  enableDragDrop = true,
  limit,
  className = ''
}: TaskListProps) {
  const {
    filters,
    sort,
    selectedTaskIds,
    isCreating,
    setCreating,
    setFilters,
    setSort,
    clearSelection
  } = useTaskStore()

  const [showFiltersPanel, setShowFiltersPanel] = useState(false)
  
  const { data: tasks = [], isLoading, error } = useTasks(filters, sort, limit)

  const handleDragEnd = (result: DropResult) => {
    if (!result.destination || !enableDragDrop) return

    // Handle reordering logic here
    // This would typically update task orders in the database
    console.log('Drag ended:', result)
  }

  const handleBulkSelect = (checked: boolean) => {
    if (checked) {
      useTaskStore.getState().setSelectedTasks(tasks.map(t => t.id))
    } else {
      clearSelection()
    }
  }

  if (error) {
    return (
      <Card className={className}>
        <CardContent className="p-6">
          <div className="text-center">
            <p className="text-red-600">Error loading tasks: {error.message}</p>
          </div>
        </CardContent>
      </Card>
    )
  }

  return (
    <div className={`space-y-4 ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between">
        <div className="flex items-center space-x-2">
          <h2 className="text-xl font-semibold">Tasks</h2>
          <span className="text-sm text-gray-500">({tasks.length})</span>
        </div>
        
        <div className="flex items-center space-x-2">
          {showFilters && (
            <Button
              variant="outline"
              size="sm"
              onClick={() => setShowFiltersPanel(!showFiltersPanel)}
            >
              <Filter className="h-4 w-4 mr-1" />
              Filters
            </Button>
          )}
          
          <Button
            size="sm"
            onClick={() => setCreating(true)}
          >
            <Plus className="h-4 w-4 mr-1" />
            Add Task
          </Button>
        </div>
      </div>

      {/* Filters Panel */}
      {showFilters && showFiltersPanel && (
        <TaskFilters
          filters={filters}
          onFiltersChange={setFilters}
          onClose={() => setShowFiltersPanel(false)}
        />
      )}

      {/* Batch Actions */}
      {showBatchActions && selectedTaskIds.length > 0 && (
        <TaskBatchActions
          selectedTaskIds={selectedTaskIds}
          onClearSelection={clearSelection}
        />
      )}

      {/* Task Creation */}
      {isCreating && (
        <Card>
          <CardContent className="p-4">
            <TaskForm
              onSuccess={() => setCreating(false)}
              onCancel={() => setCreating(false)}
            />
          </CardContent>
        </Card>
      )}

      {/* Task List */}
      <div className="space-y-2">
        {isLoading ? (
          // Loading skeletons
          [...Array(limit || 5)].map((_, i) => (
            <Card key={i}>
              <CardContent className="p-4">
                <div className="space-y-2">
                  <Skeleton className="h-5 w-3/4" />
                  <Skeleton className="h-4 w-1/2" />
                </div>
              </CardContent>
            </Card>
          ))
        ) : tasks.length === 0 ? (
          // Empty state
          <Card>
            <CardContent className="p-8">
              <div className="text-center">
                <div className="mx-auto h-12 w-12 text-gray-400 mb-4">
                  <MoreHorizontal className="h-full w-full" />
                </div>
                <h3 className="text-lg font-medium text-gray-900 mb-2">
                  No tasks found
                </h3>
                <p className="text-gray-500 mb-4">
                  Get started by creating your first task
                </p>
                <Button onClick={() => setCreating(true)}>
                  <Plus className="h-4 w-4 mr-1" />
                  Add Task
                </Button>
              </div>
            </CardContent>
          </Card>
        ) : enableDragDrop ? (
          // Drag and drop list
          <DragDropContext onDragEnd={handleDragEnd}>
            <Droppable droppableId="task-list">
              {(provided) => (
                <div
                  {...provided.droppableProps}
                  ref={provided.innerRef}
                  className="space-y-2"
                >
                  {tasks.map((task, index) => (
                    <Draggable
                      key={task.id}
                      draggableId={task.id}
                      index={index}
                    >
                      {(provided, snapshot) => (
                        <div
                          ref={provided.innerRef}
                          {...provided.draggableProps}
                          {...provided.dragHandleProps}
                          className={`${
                            snapshot.isDragging ? 'rotate-3 scale-105' : ''
                          } transition-transform`}
                        >
                          <TaskItem 
                            task={task}
                            isSelected={selectedTaskIds.includes(task.id)}
                            isDragging={snapshot.isDragging}
                          />
                        </div>
                      )}
                    </Draggable>
                  ))}
                  {provided.placeholder}
                </div>
              )}
            </Droppable>
          </DragDropContext>
        ) : (
          // Regular list
          <div className="space-y-2">
            {tasks.map((task) => (
              <TaskItem
                key={task.id}
                task={task}
                isSelected={selectedTaskIds.includes(task.id)}
              />
            ))}
          </div>
        )}
      </div>
    </div>
  )
}
```

#### Create `components/tasks/TaskItem.tsx`:
```typescript
'use client'

import { useState } from 'react'
import { ExtendedTask } from '@/types/task'
import { TaskForm } from './TaskForm'
import { useUpdateTask, useDeleteTask } from '@/hooks/useTasks'
import { useTaskStore } from '@/stores/taskStore'
import { Card, CardContent } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Checkbox } from '@/components/ui/checkbox'
import { Badge } from '@/components/ui/badge'
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu'
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from '@/components/ui/alert-dialog'
import {
  Calendar,
  Clock,
  MoreHorizontal,
  Edit,
  Trash2,
  CheckCircle,
  Circle,
  Play,
  Pause,
  Tag,
  AlertTriangle,
} from 'lucide-react'
import { formatDistanceToNow, format } from 'date-fns'
import { cn } from '@/lib/utils'

interface TaskItemProps {
  task: ExtendedTask
  isSelected?: boolean
  isDragging?: boolean
  compact?: boolean
}

export function TaskItem({
  task,
  isSelected = false,
  isDragging = false,
  compact = false,
}: TaskItemProps) {
  const [isEditing, setIsEditing] = useState(false)
  const [showDeleteDialog, setShowDeleteDialog] = useState(false)
  
  const { toggleTaskSelection } = useTaskStore()
  const updateTask = useUpdateTask()
  const deleteTask = useDeleteTask()

  const handleStatusToggle = () => {
    const newStatus = task.status === 'completed' ? 'todo' : 'completed'
    updateTask.mutate({
      taskId: task.id,
      updates: { status: newStatus }
    })
  }

  const handleDelete = () => {
    deleteTask.mutate(task.id)
    setShowDeleteDialog(false)
  }

  const priorityColors = {
    low: 'bg-gray-100 text-gray-700 border-gray-200',
    medium: 'bg-blue-100 text-blue-700 border-blue-200',
    high: 'bg-orange-100 text-orange-700 border-orange-200',
    urgent: 'bg-red-100 text-red-700 border-red-200',
  }

  const statusIcons = {
    todo: Circle,
    in_progress: Play,
    completed: CheckCircle,
    archived: Pause,
  }

  const StatusIcon = statusIcons[task.status]

  return (
    <>
      <Card
        className={cn(
          'transition-all duration-200 hover:shadow-md',
          isSelected && 'ring-2 ring-blue-500',
          isDragging && 'shadow-lg',
          task.status === 'completed' && 'opacity-75',
          task.overdue && 'border-l-4 border-l-red-500',
          compact && 'p-2'
        )}
      >
        <CardContent className={cn('p-4', compact && 'p-2')}>
          {isEditing ? (
            <TaskForm
              task={task}
              onSuccess={() => setIsEditing(false)}
              onCancel={() => setIsEditing(false)}
            />
          ) : (
            <div className="flex items-start space-x-3">
              {/* Selection checkbox */}
              <Checkbox
                checked={isSelected}
                onCheckedChange={() => toggleTaskSelection(task.id)}
                className="mt-1"
              />

              {/* Status toggle */}
              <button
                onClick={handleStatusToggle}
                className={cn(
                  'flex-shrink-0 mt-0.5 transition-colors',
                  task.status === 'completed' ? 'text-green-600' : 'text-gray-400 hover:text-gray-600'
                )}
              >
                <StatusIcon className="h-5 w-5" />
              </button>

              {/* Content */}
              <div className="flex-1 min-w-0">
                <div className="flex items-start justify-between">
                  <div className="flex-1">
                    {/* Title */}
                    <h3
                      className={cn(
                        'text-sm font-medium text-gray-900 mb-1',
                        task.status === 'completed' && 'line-through text-gray-500'
                      )}
                    >
                      {task.title}
                    </h3>

                    {/* Description */}
                    {task.description && !compact && (
                      <p className="text-sm text-gray-600 mb-2 line-clamp-2">
                        {task.description}
                      </p>
                    )}

                    {/* Metadata row */}
                    <div className="flex items-center space-x-4 text-xs text-gray-500">
                      {/* Priority */}
                      <Badge
                        variant="outline"
                        className={cn('text-xs', priorityColors[task.priority])}
                      >
                        {task.priority}
                      </Badge>

                      {/* Project */}
                      {task.project && (
                        <div className="flex items-center space-x-1">
                          <div
                            className="w-2 h-2 rounded-full"
                            style={{ backgroundColor: task.project.color }}
                          />
                          <span>{task.project.name}</span>
                        </div>
                      )}

                      {/* Due date */}
                      {task.due_date && (
                        <div className={cn(
                          'flex items-center space-x-1',
                          task.overdue && 'text-red-600',
                          task.dueToday && 'text-orange-600',
                          task.dueSoon && 'text-yellow-600'
                        )}>
                          <Calendar className="h-3 w-3" />
                          <span>
                            {task.overdue && <AlertTriangle className="h-3 w-3 inline mr-1" />}
                            {format(new Date(task.due_date), 'MMM d')}
                          </span>
                        </div>
                      )}

                      {/* Time estimate */}
                      {task.estimated_minutes && (
                        <div className="flex items-center space-x-1">
                          <Clock className="h-3 w-3" />
                          <span>{task.estimated_minutes}m</span>
                        </div>
                      )}

                      {/* Tags */}
                      {task.tags.length > 0 && !compact && (
                        <div className="flex items-center space-x-1">
                          <Tag className="h-3 w-3" />
                          <div className="flex space-x-1">
                            {task.tags.slice(0, 2).map(tag => (
                              <Badge key={tag} variant="secondary" className="text-xs">
                                {tag}
                              </Badge>
                            ))}
                            {task.tags.length > 2 && (
                              <span className="text-gray-400">+{task.tags.length - 2}</span>
                            )}
                          </div>
                        </div>
                      )}
                    </div>
                  </div>

                  {/* Actions menu */}
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="sm">
                        <MoreHorizontal className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem onClick={() => setIsEditing(true)}>
                        <Edit className="h-4 w-4 mr-2" />
                        Edit
                      </DropdownMenuItem>
                      <DropdownMenuItem
                        onClick={() => setShowDeleteDialog(true)}
                        className="text-red-600"
                      >
                        <Trash2 className="h-4 w-4 mr-2" />
                        Delete
                      </DropdownMenuItem>
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
            </div>
          )}
        </CardContent>
      </Card>

      {/* Delete confirmation dialog */}
      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Task</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete "{task.title}"? This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel>Cancel</AlertDialogCancel>
            <AlertDialogAction
              onClick={handleDelete}
              className="bg-red-600 hover:bg-red-700"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </>
  )
}
```

### 6. Task Creation Form

#### Create `components/tasks/TaskForm.tsx`:
```typescript
'use client'

import { useState, useEffect } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import * as z from 'zod'
import { ExtendedTask, TaskFormData } from '@/types/task'
import { useCreateTask, useUpdateTask } from '@/hooks/useTasks'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Label } from '@/components/ui/label'
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select'
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'
import { Badge } from '@/components/ui/badge'
import { X, Plus, Calendar, Clock } from 'lucide-react'

const taskFormSchema = z.object({
  title: z.string().min(1, 'Title is required').max(500, 'Title too long'),
  description: z.string().optional(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']),
  due_date: z.string().optional(),
  scheduled_date: z.string().optional(),
  project_id: z.string().optional(),
  tags: z.array(z.string()),
  context: z.string().optional(),
  energy_level: z.enum(['morning', 'afternoon', 'evening', 'anytime']).optional(),
  estimated_minutes: z.number().min(1).max(480).optional(),
})

interface TaskFormProps {
  task?: ExtendedTask
  onSuccess: () => void
  onCancel: () => void
}

export function TaskForm({ task, onSuccess, onCancel }: TaskFormProps) {
  const [newTag, setNewTag] = useState('')
  
  const createTask = useCreateTask()
  const updateTask = useUpdateTask()
  
  const isEditing = !!task

  const form = useForm<TaskFormData>({
    resolver: zodResolver(taskFormSchema),
    defaultValues: {
      title: task?.title || '',
      description: task?.description || '',
      priority: task?.priority || 'medium',
      due_date: task?.due_date ? task.due_date.split('T')[0] : '',
      scheduled_date: task?.scheduled_date || '',
      project_id: task?.project_id || '',
      tags: task?.tags || [],
      context: task?.context || '',
      energy_level: task?.energy_level || 'anytime',
      estimated_minutes: task?.estimated_minutes || undefined,
    },
  })

  const onSubmit = async (data: TaskFormData) => {
    try {
      if (isEditing && task) {
        await updateTask.mutateAsync({
          taskId: task.id,
          updates: data,
        })
      } else {
        await createTask.mutateAsync(data)
      }
      onSuccess()
    } catch (error) {
      console.error('Form submission error:', error)
    }
  }

  const handleAddTag = () => {
    if (newTag.trim()) {
      const currentTags = form.getValues('tags')
      if (!currentTags.includes(newTag.trim())) {
        form.setValue('tags', [...currentTags, newTag.trim()])
      }
      setNewTag('')
    }
  }

  const handleRemoveTag = (tagToRemove: string) => {
    const currentTags = form.getValues('tags')
    form.setValue('tags', currentTags.filter(tag => tag !== tagToRemove))
  }

  const isSubmitting = createTask.isLoading || updateTask.isLoading

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        {/* Title */}
        <FormField
          control={form.control}
          name="title"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Title</FormLabel>
              <FormControl>
                <Input
                  placeholder="What needs to be done?"
                  {...field}
                  autoFocus
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Description */}
        <FormField
          control={form.control}
          name="description"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Description</FormLabel>
              <FormControl>
                <Textarea
                  placeholder="Add more details..."
                  rows={3}
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        <div className="grid grid-cols-2 gap-4">
          {/* Priority */}
          <FormField
            control={form.control}
            name="priority"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Priority</FormLabel>
                <Select onValueChange={field.onChange} defaultValue={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="Select priority" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="low">Low</SelectItem>
                    <SelectItem value="medium">Medium</SelectItem>
                    <SelectItem value="high">High</SelectItem>
                    <SelectItem value="urgent">Urgent</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* Energy Level */}
          <FormField
            control={form.control}
            name="energy_level"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Energy Level</FormLabel>
                <Select onValueChange={field.onChange} defaultValue={field.value}>
                  <FormControl>
                    <SelectTrigger>
                      <SelectValue placeholder="When to do this?" />
                    </SelectTrigger>
                  </FormControl>
                  <SelectContent>
                    <SelectItem value="anytime">Anytime</SelectItem>
                    <SelectItem value="morning">Morning</SelectItem>
                    <SelectItem value="afternoon">Afternoon</SelectItem>
                    <SelectItem value="evening">Evening</SelectItem>
                  </SelectContent>
                </Select>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        <div className="grid grid-cols-2 gap-4">
          {/* Due Date */}
          <FormField
            control={form.control}
            name="due_date"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Due Date</FormLabel>
                <FormControl>
                  <div className="relative">
                    <Calendar className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      type="date"
                      className="pl-10"
                      {...field}
                    />
                  </div>
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          {/* Time Estimate */}
          <FormField
            control={form.control}
            name="estimated_minutes"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Time Estimate (minutes)</FormLabel>
                <FormControl>
                  <div className="relative">
                    <Clock className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
                    <Input
                      type="number"
                      placeholder="0"
                      className="pl-10"
                      {...field}
                      onChange={(e) => field.onChange(e.target.value ? parseInt(e.target.value) : undefined)}
                    />
                  </div>
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
        </div>

        {/* Context */}
        <FormField
          control={form.control}
          name="context"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Context</FormLabel>
              <FormControl>
                <Input
                  placeholder="@home, @work, @calls, @errands"
                  {...field}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* Tags */}
        <div className="space-y-2">
          <Label>Tags</Label>
          <div className="flex space-x-2">
            <Input
              value={newTag}
              onChange={(e) => setNewTag(e.target.value)}
              placeholder="Add a tag..."
              onKeyPress={(e) => {
                if (e.key === 'Enter') {
                  e.preventDefault()
                  handleAddTag()
                }
              }}
            />
            <Button
              type="button"
              variant="outline"
              onClick={handleAddTag}
              disabled={!newTag.trim()}
            >
              <Plus className="h-4 w-4" />
            </Button>
          </div>
          {form.watch('tags').length > 0 && (
            <div className="flex flex-wrap gap-2 mt-2">
              {form.watch('tags').map((tag) => (
                <Badge key={tag} variant="secondary" className="flex items-center space-x-1">
                  <span>{tag}</span>
                  <button
                    type="button"
                    onClick={() => handleRemoveTag(tag)}
                    className="ml-1 hover:bg-gray-300 rounded-full p-0.5"
                  >
                    <X className="h-3 w-3" />
                  </button>
                </Badge>
              ))}
            </div>
          )}
        </div>

        {/* Actions */}
        <div className="flex space-x-2 pt-4">
          <Button
            type="submit"
            disabled={isSubmitting}
          >
            {isSubmitting ? 'Saving...' : isEditing ? 'Update Task' : 'Create Task'}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={onCancel}
            disabled={isSubmitting}
          >
            Cancel
          </Button>
        </div>
      </form>
    </Form>
  )
}
```

## Acceptance Criteria
- [ ] Create new tasks with comprehensive form including all fields
- [ ] Display tasks in optimized list view with filtering and sorting
- [ ] Edit tasks inline with toggle functionality and modal view
- [ ] Delete tasks with confirmation dialog and undo capability
- [ ] Optimistic updates for all CRUD operations with error recovery
- [ ] Real-time sync across browser tabs using Supabase subscriptions
- [ ] Drag and drop to reorder tasks with visual feedback
- [ ] Batch operations for multiple task selection and actions
- [ ] Advanced filtering by status, priority, project, tags, and dates
- [ ] Search functionality across task titles and descriptions
- [ ] Task status toggles with visual indicators
- [ ] Priority badges with color coding
- [ ] Due date warnings and overdue indicators
- [ ] Time estimates and tracking capabilities
- [ ] Project association with color coding
- [ ] Tag management with auto-complete
- [ ] Context categorization (@home, @work, etc.)
- [ ] Energy level assignment for smart scheduling
- [ ] Comprehensive error handling with user feedback
- [ ] Loading states for all operations
- [ ] Empty states with helpful messaging
- [ ] Responsive design for mobile and desktop
- [ ] Keyboard shortcuts for common operations
- [ ] Accessibility features (proper ARIA labels, focus management)

## Technical Details
- React Query with optimistic updates and error recovery
- Zustand store for complex UI state management
- Real-time Supabase subscriptions for multi-tab sync
- React Beautiful DnD for drag and drop functionality
- React Hook Form with Zod validation for forms
- Comprehensive TypeScript types for type safety
- Custom hooks for reusable logic
- Proper error boundaries and fallback UI
- Performance optimizations with proper memoization
- Debounced search and filtering
- Virtual scrolling for large task lists
- Batch operations with confirmation dialogs
- Undo/redo functionality with action history

## Dependencies
- [ ] Task 003 completed (Authentication working)
- [ ] Database schema ready with all required tables
- [ ] React Query and Zustand installed
- [ ] shadcn/ui components available
- [ ] React Beautiful DnD installed
- [ ] React Hook Form and Zod installed

## Effort Estimate
- Size: XL
- Hours: 16
- Parallel: false

## Definition of Done
- [ ] All CRUD operations working with proper error handling
- [ ] Optimistic updates implemented with error recovery
- [ ] Real-time sync verified across multiple browser tabs
- [ ] Drag and drop functionality working smoothly
- [ ] Batch operations tested and working
- [ ] Advanced filtering and search implemented
- [ ] Form validation working correctly
- [ ] Loading and empty states implemented
- [ ] Responsive design tested on multiple devices
- [ ] Accessibility features implemented and tested
- [ ] Error boundaries and proper error handling
- [ ] Unit tests for custom hooks written and passing
- [ ] Integration tests for CRUD operations
- [ ] Performance optimizations verified
- [ ] TypeScript types comprehensive and accurate
- [ ] Documentation updated with component API
