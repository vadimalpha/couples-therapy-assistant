---
name: Quick Capture
status: open
created: 2025-08-26T18:29:07Z
updated: 2025-08-26T20:52:21Z
github: https://github.com/vadimalpha/taskmanager/issues/7
depends_on: [004]
parallel: true
conflicts_with: [005]
---

# Task: Quick Capture

## Description
Implement a powerful command palette interface for quick task capture with natural language processing, smart suggestions, voice input, and global keyboard shortcuts. Enable users to rapidly create tasks, search content, and execute commands from anywhere in the application.

## Detailed Implementation Specification

### 1. Command Palette Types and State

#### Create `types/command.ts`:
```typescript
export type CommandType = 'task' | 'search' | 'navigation' | 'action' | 'focus'

export interface Command {
  id: string
  type: CommandType
  title: string
  subtitle?: string
  keywords: string[]
  icon?: string
  action: () => Promise<void> | void
  shortcut?: string
  group?: string
  priority?: number
  recent?: boolean
}

export interface CommandGroup {
  id: string
  title: string
  commands: Command[]
  priority: number
}

export interface ParsedCommand {
  action: string
  title?: string
  description?: string
  dueDate?: Date
  priority?: 'low' | 'medium' | 'high' | 'urgent'
  tags?: string[]
  project?: string
  context?: string
  energyLevel?: string
  estimatedMinutes?: number
  confidence: number
}

export interface RecentCommand {
  command: string
  timestamp: Date
  type: CommandType
  frequency: number
}

export interface CommandPaletteState {
  isOpen: boolean
  query: string
  selectedIndex: number
  recentCommands: RecentCommand[]
  isListening: boolean
  voiceInput: string
}
```

#### Update `stores/commandStore.ts`:
```typescript
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'
import { Command, RecentCommand, ParsedCommand } from '@/types/command'

interface CommandState {
  // UI State
  isOpen: boolean
  query: string
  selectedIndex: number
  isListening: boolean
  voiceInput: string
  
  // Commands and History
  commands: Command[]
  recentCommands: RecentCommand[]
  filteredCommands: Command[]
  
  // Settings
  enableVoiceInput: boolean
  maxRecentCommands: number
  
  // Actions
  setOpen: (open: boolean) => void
  setQuery: (query: string) => void
  setSelectedIndex: (index: number) => void
  setListening: (listening: boolean) => void
  setVoiceInput: (input: string) => void
  addRecentCommand: (command: string, type: string) => void
  clearRecentCommands: () => void
  updateCommands: (commands: Command[]) => void
  filterCommands: (query: string) => void
  executeCommand: (command: Command) => void
}

export const useCommandStore = create<CommandState>()(
  devtools(
    persist(
      (set, get) => ({
        // Initial state
        isOpen: false,
        query: '',
        selectedIndex: 0,
        isListening: false,
        voiceInput: '',
        commands: [],
        recentCommands: [],
        filteredCommands: [],
        enableVoiceInput: true,
        maxRecentCommands: 10,
        
        // Actions
        setOpen: (open) => {
          set({ isOpen: open })
          if (open) {
            // Reset state when opening
            set({ query: '', selectedIndex: 0, voiceInput: '' })
          }
        },
        
        setQuery: (query) => {
          set({ query, selectedIndex: 0 })
          get().filterCommands(query)
        },
        
        setSelectedIndex: (index) => set({ selectedIndex: index }),
        
        setListening: (listening) => set({ isListening: listening }),
        
        setVoiceInput: (input) => {
          set({ voiceInput: input, query: input })
          get().filterCommands(input)
        },
        
        addRecentCommand: (command, type) => {
          set((state) => {
            const existing = state.recentCommands.find(r => r.command === command)
            
            if (existing) {
              // Update frequency and timestamp
              return {
                recentCommands: state.recentCommands.map(r =>
                  r.command === command
                    ? { ...r, timestamp: new Date(), frequency: r.frequency + 1 }
                    : r
                ).sort((a, b) => b.frequency - a.frequency)
              }
            } else {
              // Add new command
              const newCommand: RecentCommand = {
                command,
                type: type as any,
                timestamp: new Date(),
                frequency: 1,
              }
              
              return {
                recentCommands: [newCommand, ...state.recentCommands]
                  .slice(0, state.maxRecentCommands)
              }
            }
          })
        },
        
        clearRecentCommands: () => set({ recentCommands: [] }),
        
        updateCommands: (commands) => {
          set({ commands })
          get().filterCommands(get().query)
        },
        
        filterCommands: (query) => {
          const { commands, recentCommands } = get()
          
          if (!query.trim()) {
            // Show recent commands when no query
            const recentCommandObjects = recentCommands
              .slice(0, 5)
              .map(recent => ({
                id: `recent-${recent.command}`,
                type: recent.type,
                title: recent.command,
                subtitle: 'Recent',
                keywords: [recent.command],
                action: () => {
                  // Re-execute the recent command
                  get().setQuery(recent.command)
                },
                recent: true,
                priority: recent.frequency,
              } as Command))
            
            set({ filteredCommands: [...recentCommandObjects, ...commands.slice(0, 8)] })
            return
          }
          
          // Fuzzy search implementation
          const filtered = commands
            .map(command => ({
              command,
              score: calculateCommandScore(command, query)
            }))
            .filter(({ score }) => score > 0)
            .sort((a, b) => b.score - a.score)
            .slice(0, 10)
            .map(({ command }) => command)
          
          set({ filteredCommands: filtered })
        },
        
        executeCommand: (command) => {
          try {
            command.action()
            get().addRecentCommand(command.title, command.type)
            get().setOpen(false)
          } catch (error) {
            console.error('Command execution failed:', error)
          }
        },
      }),
      {
        name: 'command-store',
        partialize: (state) => ({
          recentCommands: state.recentCommands,
          enableVoiceInput: state.enableVoiceInput,
          maxRecentCommands: state.maxRecentCommands,
        }),
      }
    ),
    { name: 'CommandStore' }
  )
)

// Fuzzy search scoring algorithm
function calculateCommandScore(command: Command, query: string): number {
  const searchText = `${command.title} ${command.subtitle || ''} ${command.keywords.join(' ')}`.toLowerCase()
  const queryLower = query.toLowerCase()
  
  // Exact match gets highest score
  if (searchText.includes(queryLower)) {
    const titleMatch = command.title.toLowerCase().includes(queryLower)
    return titleMatch ? 100 : 80
  }
  
  // Calculate fuzzy match score
  let score = 0
  const queryWords = queryLower.split(' ').filter(w => w.length > 0)
  
  for (const word of queryWords) {
    if (searchText.includes(word)) {
      score += word.length * 10
    }
    
    // Check for partial matches
    for (const searchWord of searchText.split(' ')) {
      if (searchWord.startsWith(word) && word.length >= 2) {
        score += word.length * 5
      }
    }
  }
  
  // Bonus for recent commands
  if (command.recent) {
    score += 20
  }
  
  // Bonus for priority
  if (command.priority) {
    score += command.priority * 5
  }
  
  return score
}
```

### 2. Natural Language Processing

#### Create `lib/nlp.ts`:
```typescript
import * as chrono from 'chrono-node'

const PRIORITY_PATTERNS = {
  urgent: /\b(urgent|asap|critical|emergency|immediately)\b/i,
  high: /\b(high|important|priority|soon)\b/i,
  medium: /\b(medium|normal|regular)\b/i,
  low: /\b(low|minor|sometime|eventually)\b/i,
}

const CONTEXT_PATTERNS = {
  home: /\b(@home|at home)\b/i,
  work: /\b(@work|at work|office)\b/i,
  calls: /\b(@calls|call|phone)\b/i,
  errands: /\b(@errands|errand|shopping|store)\b/i,
  computer: /\b(@computer|online|digital)\b/i,
}

const ENERGY_PATTERNS = {
  morning: /\b(morning|am|early)\b/i,
  afternoon: /\b(afternoon|pm|lunch)\b/i,
  evening: /\b(evening|night|late)\b/i,
}

const TIME_ESTIMATE_PATTERNS = {
  pattern: /\b(\d+)\s*(min|mins|minute|minutes|hour|hours|hr|hrs)\b/i,
  multipliers: {
    min: 1, mins: 1, minute: 1, minutes: 1,
    hour: 60, hours: 60, hr: 60, hrs: 60,
  }
}

const TAG_PATTERN = /#([a-zA-Z0-9_-]+)/g
const PROJECT_PATTERN = /\+([a-zA-Z0-9_-]+)/g

export class NaturalLanguageProcessor {
  static parseCommand(input: string): ParsedCommand {
    const cleanInput = input.trim()
    let confidence = 0
    
    // Determine action type
    const action = this.extractAction(cleanInput)
    confidence += action ? 30 : 0
    
    // Extract title (remove special markers)
    const title = this.extractTitle(cleanInput)
    confidence += title ? 20 : 0
    
    // Parse date/time
    const dueDate = this.extractDueDate(cleanInput)
    confidence += dueDate ? 20 : 0
    
    // Extract priority
    const priority = this.extractPriority(cleanInput)
    confidence += priority ? 10 : 0
    
    // Extract tags
    const tags = this.extractTags(cleanInput)
    confidence += tags.length > 0 ? 10 : 0
    
    // Extract project
    const project = this.extractProject(cleanInput)
    confidence += project ? 10 : 0
    
    // Extract context
    const context = this.extractContext(cleanInput)
    confidence += context ? 5 : 0
    
    // Extract energy level
    const energyLevel = this.extractEnergyLevel(cleanInput)
    confidence += energyLevel ? 5 : 0
    
    // Extract time estimate
    const estimatedMinutes = this.extractTimeEstimate(cleanInput)
    confidence += estimatedMinutes ? 5 : 0
    
    return {
      action: action || 'create_task',
      title,
      dueDate,
      priority,
      tags,
      project,
      context,
      energyLevel,
      estimatedMinutes,
      confidence: Math.min(confidence, 100)
    }
  }
  
  private static extractAction(input: string): string | null {
    const actionPatterns = {
      create_task: /^(create|add|new|make)\s+task/i,
      search: /^(search|find|look for)/i,
      focus: /^(focus|concentrate|start|begin)/i,
      complete: /^(complete|done|finish)/i,
      delete: /^(delete|remove|cancel)/i,
    }
    
    for (const [action, pattern] of Object.entries(actionPatterns)) {
      if (pattern.test(input)) {
        return action
      }
    }
    
    // Default to create_task if no explicit action
    return input.length > 0 ? 'create_task' : null
  }
  
  private static extractTitle(input: string): string {
    let title = input
    
    // Remove action prefixes
    title = title.replace(/^(create|add|new|make)\s+(task\s+)?/i, '')
    
    // Remove date expressions
    const parsedDates = chrono.parse(title)
    for (const date of parsedDates) {
      title = title.replace(date.text, '')
    }
    
    // Remove priority keywords
    for (const pattern of Object.values(PRIORITY_PATTERNS)) {
      title = title.replace(pattern, '')
    }
    
    // Remove context markers
    for (const pattern of Object.values(CONTEXT_PATTERNS)) {
      title = title.replace(pattern, '')
    }
    
    // Remove energy level keywords
    for (const pattern of Object.values(ENERGY_PATTERNS)) {
      title = title.replace(pattern, '')
    }
    
    // Remove time estimates
    title = title.replace(TIME_ESTIMATE_PATTERNS.pattern, '')
    
    // Remove tags and projects (but keep them for extraction)
    title = title.replace(TAG_PATTERN, '')
    title = title.replace(PROJECT_PATTERN, '')
    
    // Clean up whitespace and punctuation
    title = title.trim().replace(/\s+/g, ' ')
    title = title.replace(/^[^\w]+|[^\w]+$/g, '') // Remove leading/trailing non-word chars
    
    return title || 'Untitled Task'
  }
  
  private static extractDueDate(input: string): Date | null {
    try {
      const results = chrono.parse(input)
      
      if (results.length > 0) {
        const parsed = results[0]
        
        // Handle relative dates
        if (parsed.start.date()) {
          return parsed.start.date()
        }
      }
      
      // Handle common patterns not caught by chrono
      const patterns = {
        today: () => new Date(),
        tomorrow: () => {
          const date = new Date()
          date.setDate(date.getDate() + 1)
          return date
        },
        'next week': () => {
          const date = new Date()
          date.setDate(date.getDate() + 7)
          return date
        },
        'next month': () => {
          const date = new Date()
          date.setMonth(date.getMonth() + 1)
          return date
        },
      }
      
      for (const [pattern, dateFunc] of Object.entries(patterns)) {
        if (input.toLowerCase().includes(pattern)) {
          return dateFunc()
        }
      }
      
      return null
    } catch (error) {
      console.warn('Date parsing error:', error)
      return null
    }
  }
  
  private static extractPriority(input: string): string | null {
    for (const [priority, pattern] of Object.entries(PRIORITY_PATTERNS)) {
      if (pattern.test(input)) {
        return priority
      }
    }
    return null
  }
  
  private static extractTags(input: string): string[] {
    const matches = input.match(TAG_PATTERN)
    return matches ? matches.map(match => match.slice(1)) : []
  }
  
  private static extractProject(input: string): string | null {
    const match = input.match(PROJECT_PATTERN)
    return match ? match[0].slice(1) : null
  }
  
  private static extractContext(input: string): string | null {
    for (const [context, pattern] of Object.entries(CONTEXT_PATTERNS)) {
      if (pattern.test(input)) {
        return context
      }
    }
    return null
  }
  
  private static extractEnergyLevel(input: string): string | null {
    for (const [level, pattern] of Object.entries(ENERGY_PATTERNS)) {
      if (pattern.test(input)) {
        return level
      }
    }
    return null
  }
  
  private static extractTimeEstimate(input: string): number | null {
    const match = input.match(TIME_ESTIMATE_PATTERNS.pattern)
    if (match) {
      const value = parseInt(match[1])
      const unit = match[2].toLowerCase()
      const multiplier = TIME_ESTIMATE_PATTERNS.multipliers[unit] || 1
      return value * multiplier
    }
    return null
  }
}

// Example usage and test cases
export const NLP_EXAMPLES = [
  {
    input: "create task review project proposal tomorrow high priority #work +projectalpha 2 hours",
    expected: {
      action: "create_task",
      title: "review project proposal",
      priority: "high",
      tags: ["work"],
      project: "projectalpha",
      estimatedMinutes: 120,
    }
  },
  {
    input: "buy groceries @errands today",
    expected: {
      action: "create_task",
      title: "buy groceries",
      context: "errands",
    }
  },
  {
    input: "call mom next week morning 15 mins",
    expected: {
      action: "create_task", 
      title: "call mom",
      energyLevel: "morning",
      estimatedMinutes: 15,
    }
  }
]
```

### 3. Voice Input Integration

#### Create `hooks/useVoiceInput.ts`:
```typescript
import { useState, useEffect, useCallback, useRef } from 'react'
import { useCommandStore } from '@/stores/commandStore'

interface VoiceInputState {
  isSupported: boolean
  isListening: boolean
  transcript: string
  error: string | null
  confidence: number
}

export function useVoiceInput() {
  const [state, setState] = useState<VoiceInputState>({
    isSupported: false,
    isListening: false,
    transcript: '',
    error: null,
    confidence: 0,
  })
  
  const recognitionRef = useRef<SpeechRecognition | null>(null)
  const timeoutRef = useRef<NodeJS.Timeout>()
  
  const { setVoiceInput, setListening } = useCommandStore()

  // Initialize speech recognition
  useEffect(() => {
    if (typeof window === 'undefined') return

    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition
    
    if (SpeechRecognition) {
      const recognition = new SpeechRecognition()
      
      recognition.continuous = true
      recognition.interimResults = true
      recognition.lang = 'en-US'
      recognition.maxAlternatives = 1
      
      recognition.onstart = () => {
        setState(prev => ({ ...prev, isListening: true, error: null }))
        setListening(true)
      }
      
      recognition.onresult = (event) => {
        let transcript = ''
        let confidence = 0
        
        for (let i = event.resultIndex; i < event.results.length; i++) {
          const result = event.results[i]
          transcript += result[0].transcript
          confidence = Math.max(confidence, result[0].confidence)
          
          // If result is final, process it
          if (result.isFinal) {
            setVoiceInput(transcript.trim())
            setState(prev => ({ 
              ...prev, 
              transcript: transcript.trim(), 
              confidence 
            }))
            
            // Auto-stop after getting final result
            stopListening()
          }
        }
        
        // Update interim results
        if (!event.results[event.resultIndex].isFinal) {
          setState(prev => ({ 
            ...prev, 
            transcript: transcript.trim(),
            confidence 
          }))
        }
      }
      
      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error)
        setState(prev => ({
          ...prev,
          error: getErrorMessage(event.error),
          isListening: false,
        }))
        setListening(false)
      }
      
      recognition.onend = () => {
        setState(prev => ({ ...prev, isListening: false }))
        setListening(false)
      }
      
      recognitionRef.current = recognition
      setState(prev => ({ ...prev, isSupported: true }))
    } else {
      setState(prev => ({
        ...prev,
        isSupported: false,
        error: 'Speech recognition not supported in this browser'
      }))
    }

    return () => {
      if (recognitionRef.current) {
        recognitionRef.current.abort()
      }
    }
  }, [setVoiceInput, setListening])

  const startListening = useCallback(() => {
    if (!recognitionRef.current || state.isListening) return

    try {
      recognitionRef.current.start()
      
      // Auto-stop after 10 seconds of listening
      timeoutRef.current = setTimeout(() => {
        stopListening()
      }, 10000)
      
    } catch (error) {
      console.error('Failed to start speech recognition:', error)
      setState(prev => ({
        ...prev,
        error: 'Failed to start voice input'
      }))
    }
  }, [state.isListening])

  const stopListening = useCallback(() => {
    if (recognitionRef.current && state.isListening) {
      recognitionRef.current.stop()
    }
    
    if (timeoutRef.current) {
      clearTimeout(timeoutRef.current)
    }
    
    setState(prev => ({ ...prev, isListening: false }))
    setListening(false)
  }, [state.isListening, setListening])

  const clearTranscript = useCallback(() => {
    setState(prev => ({ ...prev, transcript: '', error: null }))
  }, [])

  return {
    ...state,
    startListening,
    stopListening,
    clearTranscript,
  }
}

function getErrorMessage(error: string): string {
  switch (error) {
    case 'network':
      return 'Network error occurred during voice recognition'
    case 'not-allowed':
      return 'Microphone permission denied'
    case 'no-speech':
      return 'No speech detected'
    case 'aborted':
      return 'Voice input was cancelled'
    case 'audio-capture':
      return 'Audio capture failed'
    case 'service-not-allowed':
      return 'Speech service not available'
    default:
      return `Voice input error: ${error}`
  }
}

// Extend the Window interface for TypeScript
declare global {
  interface Window {
    SpeechRecognition: typeof SpeechRecognition
    webkitSpeechRecognition: typeof SpeechRecognition
  }
}
```

### 4. Command Palette Component

#### Create `components/command/CommandPalette.tsx`:
```typescript
'use client'

import { useEffect, useCallback, useRef } from 'react'
import { useCommandStore } from '@/stores/commandStore'
import { useVoiceInput } from '@/hooks/useVoiceInput'
import { useCommands } from '@/hooks/useCommands'
import { NaturalLanguageProcessor } from '@/lib/nlp'
import { Dialog, DialogContent } from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { Badge } from '@/components/ui/badge'
import { Separator } from '@/components/ui/separator'
import {
  Command,
  CommandDialog,
  CommandEmpty,
  CommandGroup,
  CommandInput,
  CommandItem,
  CommandList,
  CommandSeparator,
} from '@/components/ui/command'
import {
  Search,
  Plus,
  Mic,
  MicOff,
  Sparkles,
  Clock,
  Hash,
  Calendar,
  Target,
  Zap,
  Coffee,
  Brain,
} from 'lucide-react'
import { cn } from '@/lib/utils'

export function CommandPalette() {
  const {
    isOpen,
    query,
    selectedIndex,
    filteredCommands,
    setOpen,
    setQuery,
    setSelectedIndex,
    executeCommand,
  } = useCommandStore()
  
  const { commands, isLoading } = useCommands()
  const voiceInput = useVoiceInput()
  const inputRef = useRef<HTMLInputElement>(null)

  // Global keyboard shortcut
  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      // Cmd+K or Ctrl+K to open command palette
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault()
        setOpen(true)
      }
      
      // ESC to close
      if (e.key === 'Escape' && isOpen) {
        setOpen(false)
      }
    }

    document.addEventListener('keydown', handleKeyDown)
    return () => document.removeEventListener('keydown', handleKeyDown)
  }, [isOpen, setOpen])

  // Focus input when opening
  useEffect(() => {
    if (isOpen && inputRef.current) {
      inputRef.current.focus()
    }
  }, [isOpen])

  // Update commands when they change
  useEffect(() => {
    if (commands.length > 0) {
      useCommandStore.getState().updateCommands(commands)
    }
  }, [commands])

  // Handle voice input
  useEffect(() => {
    if (voiceInput.transcript) {
      setQuery(voiceInput.transcript)
    }
  }, [voiceInput.transcript, setQuery])

  const handleInputChange = useCallback((value: string) => {
    setQuery(value)
  }, [setQuery])

  const handleCommandSelect = useCallback((command) => {
    executeCommand(command)
  }, [executeCommand])

  const handleVoiceToggle = useCallback(() => {
    if (voiceInput.isListening) {
      voiceInput.stopListening()
    } else {
      voiceInput.startListening()
    }
  }, [voiceInput])

  // Parse natural language command
  const parsedCommand = query ? NaturalLanguageProcessor.parseCommand(query) : null
  const showNLPreview = parsedCommand && parsedCommand.confidence > 50 && parsedCommand.title

  return (
    <CommandDialog open={isOpen} onOpenChange={setOpen}>
      <div className="flex flex-col h-full max-h-[600px]">
        {/* Header with input and voice control */}
        <div className="flex items-center border-b p-3 space-x-3">
          <div className="flex-1 relative">
            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-400" />
            <CommandInput
              ref={inputRef}
              placeholder="Type a command or describe a task..."
              value={query}
              onValueChange={handleInputChange}
              className="pl-10 pr-12"
            />
            {voiceInput.isSupported && (
              <Button
                variant="ghost"
                size="sm"
                onClick={handleVoiceToggle}
                disabled={!voiceInput.isSupported}
                className={cn(
                  "absolute right-2 top-1/2 transform -translate-y-1/2 h-6 w-6 p-0",
                  voiceInput.isListening && "text-red-500 animate-pulse"
                )}
              >
                {voiceInput.isListening ? <MicOff className="h-4 w-4" /> : <Mic className="h-4 w-4" />}
              </Button>
            )}
          </div>
          
          {voiceInput.isListening && (
            <div className="flex items-center space-x-2 text-sm text-red-600">
              <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
              <span>Listening...</span>
            </div>
          )}
        </div>

        {/* Natural Language Preview */}
        {showNLPreview && (
          <div className="p-3 bg-blue-50 border-b">
            <div className="flex items-center space-x-2 mb-2">
              <Sparkles className="h-4 w-4 text-blue-600" />
              <span className="text-sm font-medium text-blue-800">Smart Parse</span>
              <Badge variant="secondary" className="text-xs">
                {parsedCommand.confidence}% confidence
              </Badge>
            </div>
            
            <div className="space-y-2">
              <div className="text-sm">
                <strong>Task:</strong> {parsedCommand.title}
              </div>
              
              <div className="flex flex-wrap gap-2 text-xs">
                {parsedCommand.priority && (
                  <Badge variant="outline" className="flex items-center space-x-1">
                    <Target className="h-3 w-3" />
                    <span>{parsedCommand.priority}</span>
                  </Badge>
                )}
                
                {parsedCommand.dueDate && (
                  <Badge variant="outline" className="flex items-center space-x-1">
                    <Calendar className="h-3 w-3" />
                    <span>{parsedCommand.dueDate.toLocaleDateString()}</span>
                  </Badge>
                )}
                
                {parsedCommand.tags && parsedCommand.tags.length > 0 && (
                  <Badge variant="outline" className="flex items-center space-x-1">
                    <Hash className="h-3 w-3" />
                    <span>{parsedCommand.tags.join(', ')}</span>
                  </Badge>
                )}
                
                {parsedCommand.estimatedMinutes && (
                  <Badge variant="outline" className="flex items-center space-x-1">
                    <Clock className="h-3 w-3" />
                    <span>{parsedCommand.estimatedMinutes}m</span>
                  </Badge>
                )}
              </div>
              
              <Button
                size="sm"
                onClick={() => {
                  // Create task from parsed command
                  const createTaskCommand = commands.find(c => c.id === 'create-task-from-nl')
                  if (createTaskCommand) {
                    createTaskCommand.action()
                  }
                }}
                className="mt-2"
              >
                <Plus className="h-4 w-4 mr-1" />
                Create Task
              </Button>
            </div>
          </div>
        )}

        {/* Commands List */}
        <CommandList className="flex-1">
          {isLoading ? (
            <div className="flex items-center justify-center p-8">
              <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-300" />
            </div>
          ) : (
            <>
              <CommandEmpty>
                <div className="text-center py-6">
                  <Search className="h-8 w-8 mx-auto text-gray-400 mb-2" />
                  <p className="text-gray-500">No commands found.</p>
                  <p className="text-sm text-gray-400 mt-1">
                    Try describing what you want to do
                  </p>
                </div>
              </CommandEmpty>

              {filteredCommands.some(c => c.recent) && (
                <CommandGroup heading="Recent">
                  {filteredCommands
                    .filter(command => command.recent)
                    .map((command) => (
                      <CommandItem
                        key={command.id}
                        value={command.id}
                        onSelect={() => handleCommandSelect(command)}
                        className="flex items-center space-x-3 p-3"
                      >
                        <Clock className="h-4 w-4 text-gray-400" />
                        <div className="flex-1">
                          <div className="font-medium">{command.title}</div>
                          {command.subtitle && (
                            <div className="text-sm text-gray-500">{command.subtitle}</div>
                          )}
                        </div>
                        {command.shortcut && (
                          <Badge variant="outline" className="text-xs">
                            {command.shortcut}
                          </Badge>
                        )}
                      </CommandItem>
                    ))}
                </CommandGroup>
              )}

              <CommandGroup heading="Actions">
                {filteredCommands
                  .filter(command => !command.recent && command.type === 'action')
                  .map((command) => (
                    <CommandItem
                      key={command.id}
                      value={command.id}
                      onSelect={() => handleCommandSelect(command)}
                      className="flex items-center space-x-3 p-3"
                    >
                      <CommandIcon type={command.type} icon={command.icon} />
                      <div className="flex-1">
                        <div className="font-medium">{command.title}</div>
                        {command.subtitle && (
                          <div className="text-sm text-gray-500">{command.subtitle}</div>
                        )}
                      </div>
                      {command.shortcut && (
                        <Badge variant="outline" className="text-xs">
                          {command.shortcut}
                        </Badge>
                      )}
                    </CommandItem>
                  ))}
              </CommandGroup>

              <CommandGroup heading="Focus Modes">
                {filteredCommands
                  .filter(command => command.type === 'focus')
                  .map((command) => (
                    <CommandItem
                      key={command.id}
                      value={command.id}
                      onSelect={() => handleCommandSelect(command)}
                      className="flex items-center space-x-3 p-3"
                    >
                      <CommandIcon type={command.type} icon={command.icon} />
                      <div className="flex-1">
                        <div className="font-medium">{command.title}</div>
                        {command.subtitle && (
                          <div className="text-sm text-gray-500">{command.subtitle}</div>
                        )}
                      </div>
                    </CommandItem>
                  ))}
              </CommandGroup>

              <CommandGroup heading="Search & Navigation">
                {filteredCommands
                  .filter(command => command.type === 'search' || command.type === 'navigation')
                  .map((command) => (
                    <CommandItem
                      key={command.id}
                      value={command.id}
                      onSelect={() => handleCommandSelect(command)}
                      className="flex items-center space-x-3 p-3"
                    >
                      <CommandIcon type={command.type} icon={command.icon} />
                      <div className="flex-1">
                        <div className="font-medium">{command.title}</div>
                        {command.subtitle && (
                          <div className="text-sm text-gray-500">{command.subtitle}</div>
                        )}
                      </div>
                    </CommandItem>
                  ))}
              </CommandGroup>
            </>
          )}
        </CommandList>

        {/* Footer */}
        <div className="border-t p-2">
          <div className="flex items-center justify-between text-xs text-gray-500">
            <div className="flex items-center space-x-4">
              <span>Press ⌘K to toggle</span>
              <span>↑↓ to navigate</span>
              <span>↵ to select</span>
            </div>
            {voiceInput.isSupported && (
              <div className="flex items-center space-x-1">
                <Mic className="h-3 w-3" />
                <span>Voice input available</span>
              </div>
            )}
          </div>
        </div>
      </div>
    </CommandDialog>
  )
}

function CommandIcon({ type, icon }: { type: string; icon?: string }) {
  const iconMap = {
    task: Plus,
    search: Search,
    navigation: Target,
    action: Zap,
    focus: Brain,
    recent: Clock,
  }

  const IconComponent = iconMap[type] || Plus
  return <IconComponent className="h-4 w-4 text-gray-500" />
}
```

### 5. Commands Hook

#### Create `hooks/useCommands.ts`:
```typescript
import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { Command } from '@/types/command'
import { useCreateTask } from '@/hooks/useTasks'
import { useFocusMode } from '@/hooks/useFocusMode'
import { useCommandStore } from '@/stores/commandStore'
import { NaturalLanguageProcessor } from '@/lib/nlp'
import { toast } from 'sonner'

export function useCommands() {
  const [commands, setCommands] = useState<Command[]>([])
  const [isLoading, setIsLoading] = useState(true)
  
  const router = useRouter()
  const createTask = useCreateTask()
  const { switchMode } = useFocusMode()
  const { query } = useCommandStore()

  useEffect(() => {
    const generateCommands = async () => {
      setIsLoading(true)
      
      const baseCommands: Command[] = [
        // Task Creation
        {
          id: 'create-task',
          type: 'action',
          title: 'Create New Task',
          subtitle: 'Add a new task to your list',
          keywords: ['create', 'add', 'new', 'task', 'todo'],
          icon: 'plus',
          action: () => {
            toast.success('Opening task creation form')
            // This would open the task creation modal
          },
          shortcut: '⌘+N',
          group: 'tasks',
          priority: 10,
        },
        
        {
          id: 'create-task-from-nl',
          type: 'action',
          title: 'Create Task from Description',
          subtitle: 'Use natural language to create a task',
          keywords: ['smart', 'parse', 'natural', 'language'],
          icon: 'sparkles',
          action: () => {
            const parsed = NaturalLanguageProcessor.parseCommand(query)
            if (parsed.confidence > 50 && parsed.title) {
              createTask.mutate({
                title: parsed.title,
                priority: parsed.priority || 'medium',
                due_date: parsed.dueDate?.toISOString(),
                tags: parsed.tags || [],
                estimated_minutes: parsed.estimatedMinutes,
                context: parsed.context,
                energy_level: parsed.energyLevel,
              })
              toast.success(`Created task: "${parsed.title}"`)
            } else {
              toast.error('Could not understand the task description')
            }
          },
          priority: 100, // High priority for NL commands
        },

        // Focus Modes
        {
          id: 'focus-daily',
          type: 'focus',
          title: 'Daily Focus Mode',
          subtitle: 'Switch to daily task view',
          keywords: ['daily', 'focus', 'today', 'mode'],
          icon: 'sun',
          action: () => {
            switchMode('daily')
            router.push('/app/focus/daily')
          },
          shortcut: '⌘+1',
          group: 'focus',
          priority: 8,
        },
        
        {
          id: 'focus-deep',
          type: 'focus',
          title: 'Deep Work Mode',
          subtitle: 'Enter distraction-free deep work',
          keywords: ['deep', 'work', 'focus', 'concentrate'],
          icon: 'brain',
          action: () => {
            switchMode('deep')
            router.push('/app/focus/deep')
          },
          shortcut: '⌘+2',
          group: 'focus',
          priority: 8,
        },
        
        {
          id: 'focus-planning',
          type: 'focus',
          title: 'Planning Mode',
          subtitle: 'Organize and schedule tasks',
          keywords: ['planning', 'schedule', 'organize', 'calendar'],
          icon: 'calendar',
          action: () => {
            switchMode('planning')
            router.push('/app/focus/planning')
          },
          shortcut: '⌘+3',
          group: 'focus',
          priority: 8,
        },
        
        {
          id: 'focus-break',
          type: 'focus',
          title: 'Break Mode',
          subtitle: 'Take a mindful break',
          keywords: ['break', 'rest', 'relax', 'pause'],
          icon: 'coffee',
          action: () => {
            switchMode('break')
            router.push('/app/focus/break')
          },
          shortcut: '⌘+4',
          group: 'focus',
          priority: 8,
        },

        // Navigation
        {
          id: 'nav-dashboard',
          type: 'navigation',
          title: 'Go to Dashboard',
          subtitle: 'Navigate to main dashboard',
          keywords: ['dashboard', 'home', 'main'],
          icon: 'home',
          action: () => router.push('/app/dashboard'),
          shortcut: '⌘+H',
          group: 'navigation',
          priority: 6,
        },
        
        {
          id: 'nav-tasks',
          type: 'navigation',
          title: 'Go to Tasks',
          subtitle: 'View all your tasks',
          keywords: ['tasks', 'list', 'todos'],
          icon: 'list',
          action: () => router.push('/app/tasks'),
          shortcut: '⌘+T',
          group: 'navigation',
          priority: 6,
        },
        
        {
          id: 'nav-analytics',
          type: 'navigation',
          title: 'Go to Analytics',
          subtitle: 'View productivity insights',
          keywords: ['analytics', 'stats', 'insights', 'reports'],
          icon: 'chart',
          action: () => router.push('/app/analytics'),
          shortcut: '⌘+A',
          group: 'navigation',
          priority: 6,
        },

        // Search
        {
          id: 'search-tasks',
          type: 'search',
          title: 'Search Tasks',
          subtitle: 'Find tasks by name or content',
          keywords: ['search', 'find', 'look', 'tasks'],
          icon: 'search',
          action: () => {
            // This would open a search interface
            toast.info('Opening task search')
          },
          shortcut: '⌘+F',
          group: 'search',
          priority: 7,
        },

        // Quick Actions
        {
          id: 'action-pomodoro',
          type: 'action',
          title: 'Start Pomodoro Timer',
          subtitle: '25-minute focus session',
          keywords: ['pomodoro', 'timer', 'focus', '25', 'minute'],
          icon: 'timer',
          action: () => {
            // Start a 25-minute focus session
            toast.success('Starting 25-minute Pomodoro session')
          },
          shortcut: '⌘+P',
          group: 'timer',
          priority: 7,
        },
        
        {
          id: 'action-quick-break',
          type: 'action',
          title: 'Take Quick Break',
          subtitle: '5-minute mindful break',
          keywords: ['break', 'pause', 'rest', '5', 'minute'],
          icon: 'pause',
          action: () => {
            switchMode('break')
            // Start 5-minute break timer
            toast.success('Starting 5-minute break')
          },
          group: 'timer',
          priority: 5,
        },
      ]

      setCommands(baseCommands)
      setIsLoading(false)
    }

    generateCommands()
  }, [router, createTask, switchMode, query])

  return { commands, isLoading }
}
```

## Acceptance Criteria
- [ ] Command palette opens with Cmd+K globally from any page
- [ ] Natural language date parsing handles relative dates ("tomorrow", "next week", "in 2 days")
- [ ] Auto-suggestions for projects, tags, and contexts based on existing data
- [ ] Quick actions for task creation, focus mode switching, and navigation
- [ ] Recent commands history with frequency-based prioritization
- [ ] Fuzzy search for existing tasks and commands with scoring algorithm
- [ ] Voice input option using Web Speech API with visual feedback
- [ ] Smart parsing of task attributes (priority, due date, tags, time estimates)
- [ ] Command palette works seamlessly from any page in the application
- [ ] Keyboard navigation with arrow keys and enter to select
- [ ] Performance optimized with sub-50ms open time and smooth interactions
- [ ] Error handling for voice input permissions and network issues
- [ ] Mobile-friendly interface with touch support
- [ ] Accessibility features with proper ARIA labels and screen reader support

## Technical Details
- React Command component with custom styling and animations
- Natural language processing with chrono-node for date parsing
- Web Speech API integration with error handling and permissions
- Zustand store for command state and recent commands persistence
- Fuzzy search algorithm with scoring based on relevance and usage frequency
- Global keyboard event listeners with proper cleanup
- Local storage for command history and user preferences
- Debounced search to prevent excessive filtering
- Lazy loading of command components for performance
- Custom hooks for voice input and command generation

## Dependencies
- [ ] Task 004 completed (Task creation API and mutations ready)
- [ ] UI command component library (cmdk or similar)
- [ ] Natural language processing library (chrono-node)
- [ ] Voice input permissions and HTTPS for Web Speech API

## Effort Estimate
- Size: L  
- Hours: 12
- Parallel: false

## Definition of Done
- [ ] Command palette fully functional with global Cmd+K shortcut
- [ ] Natural language parsing working for dates, priorities, and task attributes
- [ ] Voice input feature implemented and tested across browsers
- [ ] Fuzzy search providing relevant results with proper scoring
- [ ] Recent commands tracked and prioritized correctly
- [ ] Smart suggestions working for projects, tags, and contexts
- [ ] Performance targets met (sub-50ms open time, smooth scrolling)
- [ ] Keyboard navigation fully functional with proper focus management
- [ ] Mobile responsive design tested on various screen sizes
- [ ] Accessibility features tested with screen readers
- [ ] Error handling for voice input and network issues
- [ ] Unit tests for NLP parsing and command scoring algorithms
- [ ] Documentation updated with keyboard shortcuts and voice commands
