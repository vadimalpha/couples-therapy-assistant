---
name: Analytics Dashboard
status: open
created: 2025-08-26T18:29:07Z
updated: 2025-08-26T20:52:21Z
github: https://github.com/vadimalpha/taskmanager/issues/10
depends_on: [004]
parallel: true
conflicts_with: []
---

# Task: Analytics Dashboard

## Description
Create productivity analytics dashboard with streak tracking, completion rates, productivity scores, and weekly insights using SQL aggregations and chart visualizations.

## Acceptance Criteria
- [ ] Daily/weekly/monthly completion stats
- [ ] Streak tracking with visual calendar
- [ ] Productivity score calculation and display
- [ ] Time-of-day productivity patterns
- [ ] Project-wise task distribution
- [ ] Export analytics data to CSV
- [ ] Responsive chart components
- [ ] Performance insights and suggestions

## Detailed Implementation Specifications

### 1. Analytics Data Types

Create `lib/types/analytics.ts`:
```typescript
export interface TaskAnalytics {
  // Basic Metrics
  totalTasks: number;
  completedTasks: number;
  pendingTasks: number;
  overdueTasks: number;
  completionRate: number;
  
  // Time-based Metrics
  avgCompletionTime: number; // in minutes
  totalTimeSpent: number; // in minutes
  
  // Streaks and Consistency
  currentStreak: number; // consecutive days with completed tasks
  longestStreak: number;
  streakHistory: StreakDay[];
  
  // Productivity Score (0-100)
  productivityScore: number;
  productivityTrend: 'up' | 'down' | 'stable';
  
  // Period Information
  period: AnalyticsPeriod;
  dateRange: {
    start: string;
    end: string;
  };
}

export interface StreakDay {
  date: string; // YYYY-MM-DD
  tasksCompleted: number;
  hasStreak: boolean;
  isToday: boolean;
  dayOfWeek: number; // 0 = Sunday
}

export interface TimeOfDayAnalytics {
  hour: number;
  completedTasks: number;
  avgCompletionRate: number;
  productivityScore: number;
}

export interface ProjectAnalytics {
  projectId: string;
  projectName: string;
  totalTasks: number;
  completedTasks: number;
  completionRate: number;
  avgTimePerTask: number;
  color: string; // for chart visualization
}

export interface DailyProductivity {
  date: string;
  completedTasks: number;
  totalTasks: number;
  completionRate: number;
  timeSpent: number; // minutes
  productivityScore: number;
  dayOfWeek: string;
}

export interface WeeklyInsight {
  type: 'achievement' | 'improvement' | 'warning' | 'tip';
  title: string;
  description: string;
  value?: number;
  trend?: 'up' | 'down' | 'stable';
  actionable?: string;
}

export enum AnalyticsPeriod {
  TODAY = 'today',
  WEEK = 'week',
  MONTH = 'month',
  QUARTER = 'quarter',
  YEAR = 'year',
  CUSTOM = 'custom'
}

export interface AnalyticsFilter {
  period: AnalyticsPeriod;
  startDate?: string;
  endDate?: string;
  projectIds?: string[];
  priorityLevels?: string[];
  tagIds?: string[];
}

export interface ProductivityPattern {
  label: string;
  description: string;
  recommendation: string;
  confidence: number; // 0-1
  data: {
    bestDays: string[];
    bestHours: number[];
    worstDays: string[];
    worstHours: number[];
  };
}
```

### 2. Analytics Engine

Create `lib/analytics/engine.ts`:
```typescript
import { TaskAnalytics, StreakDay, AnalyticsPeriod, WeeklyInsight, ProductivityPattern } from '../types/analytics';
import { Task } from '../types/task';
import { startOfWeek, endOfWeek, startOfMonth, endOfMonth, format, 
         differenceInDays, eachDayOfInterval, isSameDay } from 'date-fns';

export class AnalyticsEngine {
  calculateAnalytics(
    tasks: Task[], 
    period: AnalyticsPeriod, 
    customDateRange?: { start: Date; end: Date }
  ): TaskAnalytics {
    const dateRange = this.getDateRange(period, customDateRange);
    const filteredTasks = this.filterTasksByDateRange(tasks, dateRange);
    const completedTasks = filteredTasks.filter(task => task.completed);

    const totalTasks = filteredTasks.length;
    const completedCount = completedTasks.length;
    const pendingTasks = filteredTasks.filter(task => !task.completed && !task.dueDate || 
      new Date(task.dueDate!) >= new Date()).length;
    const overdueTasks = filteredTasks.filter(task => !task.completed && task.dueDate && 
      new Date(task.dueDate) < new Date()).length;

    const completionRate = totalTasks > 0 ? (completedCount / totalTasks) * 100 : 0;
    
    const timeMetrics = this.calculateTimeMetrics(completedTasks);
    const streakData = this.calculateStreakData(tasks);
    const productivityScore = this.calculateProductivityScore(
      completionRate, 
      timeMetrics.avgCompletionTime, 
      overdueTasks,
      totalTasks
    );

    return {
      totalTasks,
      completedTasks: completedCount,
      pendingTasks,
      overdueTasks,
      completionRate: Math.round(completionRate * 100) / 100,
      avgCompletionTime: timeMetrics.avgCompletionTime,
      totalTimeSpent: timeMetrics.totalTimeSpent,
      currentStreak: streakData.currentStreak,
      longestStreak: streakData.longestStreak,
      streakHistory: streakData.streakHistory,
      productivityScore: Math.round(productivityScore),
      productivityTrend: this.calculateProductivityTrend(tasks, period),
      period,
      dateRange: {
        start: dateRange.start.toISOString(),
        end: dateRange.end.toISOString()
      }
    };
  }

  private getDateRange(period: AnalyticsPeriod, customRange?: { start: Date; end: Date }) {
    const now = new Date();
    
    switch (period) {
      case AnalyticsPeriod.TODAY:
        return { 
          start: new Date(now.getFullYear(), now.getMonth(), now.getDate()), 
          end: now 
        };
      case AnalyticsPeriod.WEEK:
        return { 
          start: startOfWeek(now), 
          end: endOfWeek(now) 
        };
      case AnalyticsPeriod.MONTH:
        return { 
          start: startOfMonth(now), 
          end: endOfMonth(now) 
        };
      case AnalyticsPeriod.QUARTER:
        const quarterStart = new Date(now.getFullYear(), Math.floor(now.getMonth() / 3) * 3, 1);
        const quarterEnd = new Date(now.getFullYear(), Math.floor(now.getMonth() / 3) * 3 + 3, 0);
        return { start: quarterStart, end: quarterEnd };
      case AnalyticsPeriod.YEAR:
        return { 
          start: new Date(now.getFullYear(), 0, 1), 
          end: new Date(now.getFullYear(), 11, 31) 
        };
      case AnalyticsPeriod.CUSTOM:
        return customRange || { start: startOfWeek(now), end: endOfWeek(now) };
      default:
        return { start: startOfWeek(now), end: endOfWeek(now) };
    }
  }

  private filterTasksByDateRange(tasks: Task[], dateRange: { start: Date; end: Date }): Task[] {
    return tasks.filter(task => {
      const taskDate = task.completedAt ? new Date(task.completedAt) : new Date(task.createdAt);
      return taskDate >= dateRange.start && taskDate <= dateRange.end;
    });
  }

  private calculateTimeMetrics(completedTasks: Task[]) {
    const tasksWithTime = completedTasks.filter(task => 
      task.startedAt && task.completedAt
    );

    if (tasksWithTime.length === 0) {
      return { avgCompletionTime: 0, totalTimeSpent: 0 };
    }

    const totalTime = tasksWithTime.reduce((sum, task) => {
      const startTime = new Date(task.startedAt!).getTime();
      const endTime = new Date(task.completedAt!).getTime();
      return sum + (endTime - startTime);
    }, 0);

    const totalMinutes = Math.floor(totalTime / (1000 * 60));
    const avgMinutes = Math.floor(totalMinutes / tasksWithTime.length);

    return {
      avgCompletionTime: avgMinutes,
      totalTimeSpent: totalMinutes
    };
  }

  private calculateStreakData(tasks: Task[]) {
    const completedTasks = tasks.filter(task => task.completed && task.completedAt);
    
    // Group tasks by date
    const tasksByDate = new Map<string, number>();
    completedTasks.forEach(task => {
      const date = format(new Date(task.completedAt!), 'yyyy-MM-dd');
      tasksByDate.set(date, (tasksByDate.get(date) || 0) + 1);
    });

    // Calculate streak history for last 90 days
    const endDate = new Date();
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 90);

    const streakHistory: StreakDay[] = eachDayOfInterval({ start: startDate, end: endDate })
      .map(date => {
        const dateStr = format(date, 'yyyy-MM-dd');
        const tasksCompleted = tasksByDate.get(dateStr) || 0;
        
        return {
          date: dateStr,
          tasksCompleted,
          hasStreak: tasksCompleted > 0,
          isToday: isSameDay(date, endDate),
          dayOfWeek: date.getDay()
        };
      });

    // Calculate current and longest streak
    let currentStreak = 0;
    let longestStreak = 0;
    let tempStreak = 0;

    // Calculate current streak (working backwards from today)
    for (let i = streakHistory.length - 1; i >= 0; i--) {
      if (streakHistory[i].hasStreak) {
        currentStreak++;
      } else {
        break;
      }
    }

    // Calculate longest streak
    streakHistory.forEach(day => {
      if (day.hasStreak) {
        tempStreak++;
        longestStreak = Math.max(longestStreak, tempStreak);
      } else {
        tempStreak = 0;
      }
    });

    return {
      currentStreak,
      longestStreak,
      streakHistory
    };
  }

  private calculateProductivityScore(
    completionRate: number, 
    avgCompletionTime: number, 
    overdueTasks: number, 
    totalTasks: number
  ): number {
    let score = 0;
    
    // Completion rate contributes 40% of score
    score += (completionRate / 100) * 40;
    
    // Time efficiency contributes 30% of score
    // Lower completion time is better (max 60 minutes for full points)
    const timeScore = Math.max(0, (60 - avgCompletionTime) / 60) * 30;
    score += timeScore;
    
    // Overdue penalty contributes 20% of score
    const overdueRate = totalTasks > 0 ? overdueTasks / totalTasks : 0;
    const overdueScore = Math.max(0, (1 - overdueRate)) * 20;
    score += overdueScore;
    
    // Consistency bonus contributes 10% of score
    const consistencyScore = completionRate > 80 ? 10 : (completionRate / 80) * 10;
    score += consistencyScore;
    
    return Math.min(100, Math.max(0, score));
  }

  private calculateProductivityTrend(tasks: Task[], period: AnalyticsPeriod): 'up' | 'down' | 'stable' {
    // Compare current period with previous period
    const now = new Date();
    let previousPeriodStart: Date;
    let previousPeriodEnd: Date;

    switch (period) {
      case AnalyticsPeriod.WEEK:
        previousPeriodStart = new Date(now);
        previousPeriodStart.setDate(now.getDate() - 14);
        previousPeriodEnd = new Date(now);
        previousPeriodEnd.setDate(now.getDate() - 7);
        break;
      case AnalyticsPeriod.MONTH:
        previousPeriodStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
        previousPeriodEnd = new Date(now.getFullYear(), now.getMonth(), 0);
        break;
      default:
        return 'stable';
    }

    const currentTasks = this.filterTasksByDateRange(tasks, { start: startOfWeek(now), end: now });
    const previousTasks = this.filterTasksByDateRange(tasks, { 
      start: previousPeriodStart, 
      end: previousPeriodEnd 
    });

    const currentRate = currentTasks.length > 0 ? 
      currentTasks.filter(t => t.completed).length / currentTasks.length : 0;
    const previousRate = previousTasks.length > 0 ? 
      previousTasks.filter(t => t.completed).length / previousTasks.length : 0;

    const difference = currentRate - previousRate;
    
    if (Math.abs(difference) < 0.05) return 'stable';
    return difference > 0 ? 'up' : 'down';
  }

  generateWeeklyInsights(analytics: TaskAnalytics, tasks: Task[]): WeeklyInsight[] {
    const insights: WeeklyInsight[] = [];
    
    // Achievement insights
    if (analytics.currentStreak >= 7) {
      insights.push({
        type: 'achievement',
        title: 'Streak Master! üî•',
        description: `You've completed tasks for ${analytics.currentStreak} consecutive days!`,
        value: analytics.currentStreak,
        trend: 'up',
        actionable: 'Keep it up! Try to reach a 30-day streak.'
      });
    }

    if (analytics.completionRate >= 90) {
      insights.push({
        type: 'achievement',
        title: 'Productivity Champion! üèÜ',
        description: `Amazing ${Math.round(analytics.completionRate)}% completion rate this period.`,
        value: analytics.completionRate,
        trend: 'up'
      });
    }

    // Improvement insights
    if (analytics.completionRate < 60) {
      insights.push({
        type: 'improvement',
        title: 'Room for Improvement üìà',
        description: `Your completion rate is ${Math.round(analytics.completionRate)}%. Let's aim higher!`,
        value: analytics.completionRate,
        trend: 'down',
        actionable: 'Try breaking large tasks into smaller, manageable pieces.'
      });
    }

    if (analytics.overdueTasks > 0) {
      insights.push({
        type: 'warning',
        title: 'Overdue Tasks Alert ‚ö†Ô∏è',
        description: `You have ${analytics.overdueTasks} overdue tasks that need attention.`,
        value: analytics.overdueTasks,
        actionable: 'Review and reschedule overdue tasks to get back on track.'
      });
    }

    // Productivity tips
    if (analytics.avgCompletionTime > 120) {
      insights.push({
        type: 'tip',
        title: 'Time Management Tip ‚è∞',
        description: `Your average task completion time is ${Math.round(analytics.avgCompletionTime)} minutes.`,
        value: analytics.avgCompletionTime,
        actionable: 'Try the Pomodoro Technique to improve focus and reduce completion time.'
      });
    }

    return insights.slice(0, 4); // Limit to top 4 insights
  }

  detectProductivityPatterns(tasks: Task[]): ProductivityPattern[] {
    const completedTasks = tasks.filter(task => task.completed && task.completedAt);
    const patterns: ProductivityPattern[] = [];

    // Analyze day-of-week patterns
    const dayStats = new Map<number, { completed: number; total: number }>();
    
    completedTasks.forEach(task => {
      const dayOfWeek = new Date(task.completedAt!).getDay();
      const stats = dayStats.get(dayOfWeek) || { completed: 0, total: 0 };
      stats.completed += 1;
      stats.total += 1;
      dayStats.set(dayOfWeek, stats);
    });

    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const bestDays = Array.from(dayStats.entries())
      .sort((a, b) => (b[1].completed / b[1].total) - (a[1].completed / a[1].total))
      .slice(0, 2)
      .map(([day]) => dayNames[day]);

    const worstDays = Array.from(dayStats.entries())
      .sort((a, b) => (a[1].completed / a[1].total) - (b[1].completed / b[1].total))
      .slice(0, 2)
      .map(([day]) => dayNames[day]);

    // Analyze hour-of-day patterns
    const hourStats = new Map<number, number>();
    
    completedTasks.forEach(task => {
      const hour = new Date(task.completedAt!).getHours();
      hourStats.set(hour, (hourStats.get(hour) || 0) + 1);
    });

    const bestHours = Array.from(hourStats.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([hour]) => hour);

    if (bestDays.length > 0 && bestHours.length > 0) {
      patterns.push({
        label: 'Peak Performance Pattern',
        description: `You're most productive on ${bestDays.join(' and ')} between ${bestHours[0]}:00-${bestHours[0] + 1}:00`,
        recommendation: `Schedule your most important tasks during these high-energy periods.`,
        confidence: Math.min(0.9, completedTasks.length / 50), // Higher confidence with more data
        data: {
          bestDays,
          bestHours,
          worstDays,
          worstHours: []
        }
      });
    }

    return patterns;
  }
}
```

### 3. Analytics Store

Create `lib/stores/analyticsStore.ts`:
```typescript
import { create } from 'zustand';
import { devtools } from 'zustand/middleware';
import { 
  TaskAnalytics, 
  AnalyticsPeriod, 
  AnalyticsFilter,
  WeeklyInsight,
  TimeOfDayAnalytics,
  ProjectAnalytics,
  DailyProductivity,
  ProductivityPattern
} from '../types/analytics';
import { AnalyticsEngine } from '../analytics/engine';
import { Task } from '../types/task';

interface AnalyticsState {
  // Data
  currentAnalytics: TaskAnalytics | null;
  timeOfDayAnalytics: TimeOfDayAnalytics[];
  projectAnalytics: ProjectAnalytics[];
  dailyProductivity: DailyProductivity[];
  weeklyInsights: WeeklyInsight[];
  productivityPatterns: ProductivityPattern[];
  
  // UI State
  selectedPeriod: AnalyticsPeriod;
  filters: AnalyticsFilter;
  isLoading: boolean;
  error: string | null;
  
  // Actions
  loadAnalytics: (tasks: Task[]) => void;
  setPeriod: (period: AnalyticsPeriod) => void;
  setFilters: (filters: Partial<AnalyticsFilter>) => void;
  exportAnalytics: (format: 'csv' | 'json') => void;
  refreshAnalytics: () => void;
  
  // Getters
  getAnalyticsForPeriod: (period: AnalyticsPeriod) => TaskAnalytics | null;
  getProductivityTrend: () => 'up' | 'down' | 'stable';
}

export const useAnalyticsStore = create<AnalyticsState>()(
  devtools(
    (set, get) => {
      const analyticsEngine = new AnalyticsEngine();

      return {
        // Initial State
        currentAnalytics: null,
        timeOfDayAnalytics: [],
        projectAnalytics: [],
        dailyProductivity: [],
        weeklyInsights: [],
        productivityPatterns: [],
        selectedPeriod: AnalyticsPeriod.WEEK,
        filters: {
          period: AnalyticsPeriod.WEEK,
          projectIds: [],
          priorityLevels: [],
          tagIds: []
        },
        isLoading: false,
        error: null,

        // Actions
        loadAnalytics: (tasks: Task[]) => {
          set({ isLoading: true, error: null });
          
          try {
            const { selectedPeriod, filters } = get();
            
            // Calculate main analytics
            const analytics = analyticsEngine.calculateAnalytics(
              tasks, 
              selectedPeriod,
              filters.startDate && filters.endDate ? {
                start: new Date(filters.startDate),
                end: new Date(filters.endDate)
              } : undefined
            );

            // Generate weekly insights
            const insights = analyticsEngine.generateWeeklyInsights(analytics, tasks);

            // Detect productivity patterns
            const patterns = analyticsEngine.detectProductivityPatterns(tasks);

            // Calculate time-of-day analytics
            const timeAnalytics = calculateTimeOfDayAnalytics(tasks);

            // Calculate project analytics
            const projectStats = calculateProjectAnalytics(tasks);

            // Calculate daily productivity
            const dailyStats = calculateDailyProductivity(tasks, selectedPeriod);

            set({
              currentAnalytics: analytics,
              weeklyInsights: insights,
              productivityPatterns: patterns,
              timeOfDayAnalytics: timeAnalytics,
              projectAnalytics: projectStats,
              dailyProductivity: dailyStats,
              isLoading: false
            });

          } catch (error) {
            set({ 
              error: error instanceof Error ? error.message : 'Failed to load analytics',
              isLoading: false 
            });
          }
        },

        setPeriod: (period: AnalyticsPeriod) => {
          set(state => ({
            selectedPeriod: period,
            filters: { ...state.filters, period }
          }));
        },

        setFilters: (newFilters: Partial<AnalyticsFilter>) => {
          set(state => ({
            filters: { ...state.filters, ...newFilters }
          }));
        },

        exportAnalytics: (format: 'csv' | 'json') => {
          const { currentAnalytics, dailyProductivity, projectAnalytics } = get();
          
          if (!currentAnalytics) return;

          const data = {
            summary: currentAnalytics,
            daily: dailyProductivity,
            projects: projectAnalytics,
            exportedAt: new Date().toISOString()
          };

          if (format === 'csv') {
            exportToCSV(data);
          } else {
            exportToJSON(data);
          }
        },

        refreshAnalytics: async () => {
          // This would typically fetch fresh task data and reload analytics
          const taskStore = useTaskStore.getState();
          get().loadAnalytics(taskStore.tasks);
        },

        // Getters
        getAnalyticsForPeriod: (period: AnalyticsPeriod) => {
          // This would return cached analytics for different periods
          // For now, return current analytics
          return get().currentAnalytics;
        },

        getProductivityTrend: () => {
          return get().currentAnalytics?.productivityTrend || 'stable';
        }
      };
    },
    { name: 'AnalyticsStore' }
  )
);

// Helper functions
function calculateTimeOfDayAnalytics(tasks: Task[]): TimeOfDayAnalytics[] {
  const completedTasks = tasks.filter(task => task.completed && task.completedAt);
  const hourlyStats = new Map<number, { completed: number; total: number }>();

  // Initialize all hours
  for (let hour = 0; hour < 24; hour++) {
    hourlyStats.set(hour, { completed: 0, total: 0 });
  }

  // Count completed tasks by hour
  completedTasks.forEach(task => {
    const hour = new Date(task.completedAt!).getHours();
    const stats = hourlyStats.get(hour)!;
    stats.completed += 1;
    stats.total += 1;
  });

  // Convert to analytics format
  return Array.from(hourlyStats.entries()).map(([hour, stats]) => ({
    hour,
    completedTasks: stats.completed,
    avgCompletionRate: stats.total > 0 ? (stats.completed / stats.total) * 100 : 0,
    productivityScore: Math.min(100, stats.completed * 10) // Simple scoring
  }));
}

function calculateProjectAnalytics(tasks: Task[]): ProjectAnalytics[] {
  const projectStats = new Map<string, { 
    name: string; 
    completed: number; 
    total: number; 
    timeSpent: number;
  }>();

  tasks.forEach(task => {
    const projectId = task.projectId || 'no-project';
    const projectName = task.project?.name || 'No Project';
    
    const stats = projectStats.get(projectId) || { 
      name: projectName, 
      completed: 0, 
      total: 0, 
      timeSpent: 0 
    };
    
    stats.total += 1;
    if (task.completed) {
      stats.completed += 1;
    }
    
    if (task.estimatedDuration) {
      stats.timeSpent += task.estimatedDuration;
    }
    
    projectStats.set(projectId, stats);
  });

  const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#06b6d4'];
  
  return Array.from(projectStats.entries()).map(([projectId, stats], index) => ({
    projectId,
    projectName: stats.name,
    totalTasks: stats.total,
    completedTasks: stats.completed,
    completionRate: stats.total > 0 ? (stats.completed / stats.total) * 100 : 0,
    avgTimePerTask: stats.total > 0 ? stats.timeSpent / stats.total : 0,
    color: colors[index % colors.length]
  }));
}

function calculateDailyProductivity(tasks: Task[], period: AnalyticsPeriod): DailyProductivity[] {
  const dailyStats = new Map<string, { 
    completed: number; 
    total: number; 
    timeSpent: number;
  }>();

  const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];

  tasks.forEach(task => {
    const date = task.completedAt ? 
      new Date(task.completedAt).toISOString().split('T')[0] : 
      new Date(task.createdAt).toISOString().split('T')[0];
    
    const stats = dailyStats.get(date) || { completed: 0, total: 0, timeSpent: 0 };
    
    stats.total += 1;
    if (task.completed) {
      stats.completed += 1;
    }
    
    if (task.estimatedDuration) {
      stats.timeSpent += task.estimatedDuration;
    }
    
    dailyStats.set(date, stats);
  });

  return Array.from(dailyStats.entries())
    .map(([date, stats]) => {
      const dateObj = new Date(date);
      const completionRate = stats.total > 0 ? (stats.completed / stats.total) * 100 : 0;
      
      return {
        date,
        completedTasks: stats.completed,
        totalTasks: stats.total,
        completionRate,
        timeSpent: stats.timeSpent,
        productivityScore: Math.min(100, completionRate * 0.7 + Math.min(30, stats.completed * 3)),
        dayOfWeek: dayNames[dateObj.getDay()]
      };
    })
    .sort((a, b) => a.date.localeCompare(b.date));
}

function exportToCSV(data: any) {
  const csvData = [
    // Summary headers
    ['Summary Analytics'],
    ['Total Tasks', data.summary.totalTasks],
    ['Completed Tasks', data.summary.completedTasks],
    ['Completion Rate', `${data.summary.completionRate}%`],
    ['Productivity Score', data.summary.productivityScore],
    ['Current Streak', data.summary.currentStreak],
    [''],
    
    // Daily productivity headers
    ['Daily Productivity'],
    ['Date', 'Completed Tasks', 'Total Tasks', 'Completion Rate', 'Time Spent (min)', 'Productivity Score'],
    ...data.daily.map((day: DailyProductivity) => [
      day.date,
      day.completedTasks,
      day.totalTasks,
      `${day.completionRate.toFixed(1)}%`,
      day.timeSpent,
      day.productivityScore
    ])
  ];

  const csvContent = csvData.map(row => 
    row.map(cell => `"${cell}"`).join(',')
  ).join('\n');

  const blob = new Blob([csvContent], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `productivity-analytics-${new Date().toISOString().split('T')[0]}.csv`;
  link.click();
  URL.revokeObjectURL(url);
}

function exportToJSON(data: any) {
  const jsonContent = JSON.stringify(data, null, 2);
  const blob = new Blob([jsonContent], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = `productivity-analytics-${new Date().toISOString().split('T')[0]}.json`;
  link.click();
  URL.revokeObjectURL(url);
}
```

### 4. Dashboard Components

Create `components/analytics/AnalyticsDashboard.tsx`:
```typescript
import React, { useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Button } from '@/components/ui/button';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { useAnalyticsStore } from '@/lib/stores/analyticsStore';
import { useTaskStore } from '@/lib/stores/taskStore';
import { AnalyticsPeriod } from '@/lib/types/analytics';
import { 
  TrendingUp, 
  Target, 
  Clock, 
  Calendar,
  Download,
  RefreshCw
} from 'lucide-react';

// Import chart components
import { ProductivityOverview } from './ProductivityOverview';
import { StreakCalendar } from './StreakCalendar';
import { TimeOfDayChart } from './TimeOfDayChart';
import { ProjectDistribution } from './ProjectDistribution';
import { WeeklyInsights } from './WeeklyInsights';
import { ProductivityTrends } from './ProductivityTrends';

export const AnalyticsDashboard: React.FC = () => {
  const { tasks } = useTaskStore();
  const {
    currentAnalytics,
    selectedPeriod,
    isLoading,
    error,
    loadAnalytics,
    setPeriod,
    exportAnalytics,
    refreshAnalytics
  } = useAnalyticsStore();

  useEffect(() => {
    if (tasks.length > 0) {
      loadAnalytics(tasks);
    }
  }, [tasks, selectedPeriod, loadAnalytics]);

  const handlePeriodChange = (period: AnalyticsPeriod) => {
    setPeriod(period);
  };

  const handleExport = (format: 'csv' | 'json') => {
    exportAnalytics(format);
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <RefreshCw className="h-8 w-8 animate-spin text-blue-500" />
        <span className="ml-2 text-gray-600">Loading analytics...</span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="text-center py-8">
        <div className="text-red-500 mb-2">Error loading analytics</div>
        <div className="text-gray-600 text-sm">{error}</div>
        <Button onClick={refreshAnalytics} className="mt-4">
          <RefreshCw className="h-4 w-4 mr-2" />
          Retry
        </Button>
      </div>
    );
  }

  if (!currentAnalytics) {
    return (
      <div className="text-center py-8 text-gray-600">
        No data available for analytics
      </div>
    );
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900">Analytics Dashboard</h1>
          <p className="text-gray-600">
            Insights into your productivity patterns and performance
          </p>
        </div>
        
        <div className="flex items-center gap-3">
          <Select
            value={selectedPeriod}
            onValueChange={(value: AnalyticsPeriod) => handlePeriodChange(value)}
          >
            <SelectTrigger className="w-32">
              <SelectValue />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value={AnalyticsPeriod.TODAY}>Today</SelectItem>
              <SelectItem value={AnalyticsPeriod.WEEK}>This Week</SelectItem>
              <SelectItem value={AnalyticsPeriod.MONTH}>This Month</SelectItem>
              <SelectItem value={AnalyticsPeriod.QUARTER}>This Quarter</SelectItem>
              <SelectItem value={AnalyticsPeriod.YEAR}>This Year</SelectItem>
            </SelectContent>
          </Select>
          
          <Button
            variant="outline"
            onClick={() => handleExport('csv')}
            className="flex items-center gap-2"
          >
            <Download className="h-4 w-4" />
            Export CSV
          </Button>
          
          <Button
            variant="outline"
            onClick={refreshAnalytics}
            className="flex items-center gap-2"
          >
            <RefreshCw className="h-4 w-4" />
            Refresh
          </Button>
        </div>
      </div>

      {/* Key Metrics */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Productivity Score</CardTitle>
            <TrendingUp className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{currentAnalytics.productivityScore}</div>
            <p className="text-xs text-muted-foreground">
              {currentAnalytics.productivityTrend === 'up' ? '‚ÜóÔ∏è Trending up' : 
               currentAnalytics.productivityTrend === 'down' ? '‚ÜòÔ∏è Trending down' : 
               '‚Üí Stable'}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Completion Rate</CardTitle>
            <Target className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{currentAnalytics.completionRate.toFixed(1)}%</div>
            <p className="text-xs text-muted-foreground">
              {currentAnalytics.completedTasks} of {currentAnalytics.totalTasks} tasks
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Current Streak</CardTitle>
            <Calendar className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{currentAnalytics.currentStreak}</div>
            <p className="text-xs text-muted-foreground">
              days ‚Ä¢ Record: {currentAnalytics.longestStreak}
            </p>
          </CardContent>
        </Card>

        <Card>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
            <CardTitle className="text-sm font-medium">Avg Time</CardTitle>
            <Clock className="h-4 w-4 text-muted-foreground" />
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{currentAnalytics.avgCompletionTime}m</div>
            <p className="text-xs text-muted-foreground">
              {Math.round(currentAnalytics.totalTimeSpent / 60)}h total
            </p>
          </CardContent>
        </Card>
      </div>

      {/* Main Content */}
      <Tabs defaultValue="overview" className="space-y-6">
        <TabsList>
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="trends">Trends</TabsTrigger>
          <TabsTrigger value="patterns">Patterns</TabsTrigger>
          <TabsTrigger value="insights">Insights</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <ProductivityOverview analytics={currentAnalytics} />
            <StreakCalendar streakHistory={currentAnalytics.streakHistory} />
          </div>
          
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <TimeOfDayChart />
            <ProjectDistribution />
          </div>
        </TabsContent>

        <TabsContent value="trends" className="space-y-6">
          <ProductivityTrends />
        </TabsContent>

        <TabsContent value="patterns" className="space-y-6">
          <Card>
            <CardHeader>
              <CardTitle>Productivity Patterns</CardTitle>
            </CardHeader>
            <CardContent>
              <p className="text-gray-600">
                Pattern analysis coming soon...
              </p>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="insights" className="space-y-6">
          <WeeklyInsights />
        </TabsContent>
      </Tabs>
    </div>
  );
};
```

### 5. Chart Components

Create `components/analytics/ProductivityOverview.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { TaskAnalytics } from '@/lib/types/analytics';
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';

interface ProductivityOverviewProps {
  analytics: TaskAnalytics;
}

export const ProductivityOverview: React.FC<ProductivityOverviewProps> = ({ analytics }) => {
  const data = [
    { name: 'Completed', value: analytics.completedTasks, color: '#10b981' },
    { name: 'Pending', value: analytics.pendingTasks, color: '#3b82f6' },
    { name: 'Overdue', value: analytics.overdueTasks, color: '#ef4444' }
  ];

  return (
    <Card>
      <CardHeader>
        <CardTitle>Task Distribution</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={data}
                cx="50%"
                cy="50%"
                innerRadius={60}
                outerRadius={100}
                paddingAngle={5}
                dataKey="value"
              >
                {data.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip />
              <Legend />
            </PieChart>
          </ResponsiveContainer>
        </div>
        
        <div className="mt-4 space-y-2">
          {data.map((item, index) => (
            <div key={index} className="flex items-center justify-between text-sm">
              <div className="flex items-center gap-2">
                <div 
                  className="w-3 h-3 rounded-full" 
                  style={{ backgroundColor: item.color }}
                />
                <span>{item.name}</span>
              </div>
              <span className="font-medium">{item.value}</span>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};
```

Create `components/analytics/StreakCalendar.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { StreakDay } from '@/lib/types/analytics';
import { format, parseISO } from 'date-fns';

interface StreakCalendarProps {
  streakHistory: StreakDay[];
}

export const StreakCalendar: React.FC<StreakCalendarProps> = ({ streakHistory }) => {
  const getIntensityClass = (tasksCompleted: number) => {
    if (tasksCompleted === 0) return 'bg-gray-100';
    if (tasksCompleted <= 2) return 'bg-green-200';
    if (tasksCompleted <= 4) return 'bg-green-300';
    if (tasksCompleted <= 6) return 'bg-green-400';
    return 'bg-green-500';
  };

  // Group by weeks for display
  const weeks: StreakDay[][] = [];
  let currentWeek: StreakDay[] = [];
  
  streakHistory.forEach((day, index) => {
    if (day.dayOfWeek === 0 && currentWeek.length > 0) {
      weeks.push(currentWeek);
      currentWeek = [];
    }
    currentWeek.push(day);
    
    if (index === streakHistory.length - 1) {
      weeks.push(currentWeek);
    }
  });

  return (
    <Card>
      <CardHeader>
        <CardTitle>Activity Calendar</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="space-y-1">
          {/* Day labels */}
          <div className="grid grid-cols-7 gap-1 text-xs text-gray-500 mb-2">
            {['S', 'M', 'T', 'W', 'T', 'F', 'S'].map((day, index) => (
              <div key={index} className="text-center">{day}</div>
            ))}
          </div>
          
          {/* Calendar grid */}
          {weeks.map((week, weekIndex) => (
            <div key={weekIndex} className="grid grid-cols-7 gap-1">
              {week.map((day, dayIndex) => (
                <div
                  key={dayIndex}
                  className={`
                    aspect-square rounded text-xs flex items-center justify-center
                    ${getIntensityClass(day.tasksCompleted)}
                    ${day.isToday ? 'ring-2 ring-blue-500' : ''}
                    hover:ring-2 hover:ring-gray-300 cursor-pointer
                    transition-all duration-200
                  `}
                  title={`${format(parseISO(day.date), 'MMM d')}: ${day.tasksCompleted} tasks completed`}
                >
                  {day.tasksCompleted > 0 && (
                    <span className="text-white font-medium">
                      {day.tasksCompleted}
                    </span>
                  )}
                </div>
              ))}
            </div>
          ))}
        </div>
        
        <div className="mt-4 flex items-center justify-between text-xs text-gray-500">
          <span>Less</span>
          <div className="flex items-center gap-1">
            <div className="w-3 h-3 bg-gray-100 rounded"></div>
            <div className="w-3 h-3 bg-green-200 rounded"></div>
            <div className="w-3 h-3 bg-green-300 rounded"></div>
            <div className="w-3 h-3 bg-green-400 rounded"></div>
            <div className="w-3 h-3 bg-green-500 rounded"></div>
          </div>
          <span>More</span>
        </div>
      </CardContent>
    </Card>
  );
};
```

Create `components/analytics/TimeOfDayChart.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useAnalyticsStore } from '@/lib/stores/analyticsStore';
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

export const TimeOfDayChart: React.FC = () => {
  const { timeOfDayAnalytics } = useAnalyticsStore();

  const data = timeOfDayAnalytics.map(item => ({
    hour: `${item.hour}:00`,
    tasks: item.completedTasks,
    productivity: item.productivityScore
  }));

  return (
    <Card>
      <CardHeader>
        <CardTitle>Productivity by Time of Day</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={data}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis 
                dataKey="hour" 
                tick={{ fontSize: 12 }}
                interval={2}
              />
              <YAxis tick={{ fontSize: 12 }} />
              <Tooltip 
                labelFormatter={(label) => `Time: ${label}`}
                formatter={(value, name) => [
                  value, 
                  name === 'tasks' ? 'Tasks Completed' : 'Productivity Score'
                ]}
              />
              <Bar dataKey="tasks" fill="#3b82f6" radius={[4, 4, 0, 0]} />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </CardContent>
    </Card>
  );
};
```

Create `components/analytics/ProjectDistribution.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useAnalyticsStore } from '@/lib/stores/analyticsStore';
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';

export const ProjectDistribution: React.FC = () => {
  const { projectAnalytics } = useAnalyticsStore();

  const data = projectAnalytics.map(project => ({
    name: project.projectName,
    value: project.totalTasks,
    completionRate: project.completionRate,
    color: project.color
  }));

  return (
    <Card>
      <CardHeader>
        <CardTitle>Tasks by Project</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-64">
          <ResponsiveContainer width="100%" height="100%">
            <PieChart>
              <Pie
                data={data}
                cx="50%"
                cy="50%"
                outerRadius={80}
                paddingAngle={2}
                dataKey="value"
              >
                {data.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={entry.color} />
                ))}
              </Pie>
              <Tooltip 
                formatter={(value, name, props) => [
                  `${value} tasks (${props.payload.completionRate.toFixed(1)}% complete)`,
                  props.payload.name
                ]}
              />
              <Legend />
            </PieChart>
          </ResponsiveContainer>
        </div>
        
        <div className="mt-4 space-y-2">
          {data.map((item, index) => (
            <div key={index} className="flex items-center justify-between text-sm">
              <div className="flex items-center gap-2">
                <div 
                  className="w-3 h-3 rounded-full" 
                  style={{ backgroundColor: item.color }}
                />
                <span className="truncate">{item.name}</span>
              </div>
              <div className="text-right">
                <div className="font-medium">{item.value} tasks</div>
                <div className="text-xs text-gray-500">
                  {item.completionRate.toFixed(1)}% done
                </div>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
};
```

Create `components/analytics/WeeklyInsights.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useAnalyticsStore } from '@/lib/stores/analyticsStore';
import { 
  Trophy, 
  TrendingUp, 
  AlertTriangle, 
  Lightbulb,
  ArrowUp,
  ArrowDown,
  Minus
} from 'lucide-react';

export const WeeklyInsights: React.FC = () => {
  const { weeklyInsights, productivityPatterns } = useAnalyticsStore();

  const getInsightIcon = (type: string) => {
    switch (type) {
      case 'achievement': return <Trophy className="h-4 w-4" />;
      case 'improvement': return <TrendingUp className="h-4 w-4" />;
      case 'warning': return <AlertTriangle className="h-4 w-4" />;
      case 'tip': return <Lightbulb className="h-4 w-4" />;
      default: return <Lightbulb className="h-4 w-4" />;
    }
  };

  const getInsightColor = (type: string) => {
    switch (type) {
      case 'achievement': return 'text-green-600 bg-green-50 border-green-200';
      case 'improvement': return 'text-blue-600 bg-blue-50 border-blue-200';
      case 'warning': return 'text-orange-600 bg-orange-50 border-orange-200';
      case 'tip': return 'text-purple-600 bg-purple-50 border-purple-200';
      default: return 'text-gray-600 bg-gray-50 border-gray-200';
    }
  };

  const getTrendIcon = (trend?: string) => {
    switch (trend) {
      case 'up': return <ArrowUp className="h-3 w-3 text-green-500" />;
      case 'down': return <ArrowDown className="h-3 w-3 text-red-500" />;
      case 'stable': return <Minus className="h-3 w-3 text-gray-500" />;
      default: return null;
    }
  };

  return (
    <div className="space-y-6">
      {/* Weekly Insights */}
      <Card>
        <CardHeader>
          <CardTitle>Weekly Insights</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {weeklyInsights.length === 0 ? (
            <p className="text-gray-500 text-center py-4">
              No insights available yet. Complete more tasks to generate insights.
            </p>
          ) : (
            weeklyInsights.map((insight, index) => (
              <div
                key={index}
                className={`p-4 rounded-lg border ${getInsightColor(insight.type)}`}
              >
                <div className="flex items-start gap-3">
                  <div className="flex-shrink-0">
                    {getInsightIcon(insight.type)}
                  </div>
                  
                  <div className="flex-1 min-w-0">
                    <div className="flex items-center gap-2 mb-1">
                      <h4 className="font-semibold text-sm">{insight.title}</h4>
                      {insight.trend && getTrendIcon(insight.trend)}
                      {insight.value && (
                        <Badge variant="secondary" className="text-xs">
                          {typeof insight.value === 'number' && insight.value % 1 === 0
                            ? insight.value
                            : typeof insight.value === 'number'
                            ? insight.value.toFixed(1)
                            : insight.value}
                        </Badge>
                      )}
                    </div>
                    
                    <p className="text-sm mb-2">{insight.description}</p>
                    
                    {insight.actionable && (
                      <div className="text-xs font-medium opacity-75">
                        üí° {insight.actionable}
                      </div>
                    )}
                  </div>
                </div>
              </div>
            ))
          )}
        </CardContent>
      </Card>

      {/* Productivity Patterns */}
      <Card>
        <CardHeader>
          <CardTitle>Productivity Patterns</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          {productivityPatterns.length === 0 ? (
            <p className="text-gray-500 text-center py-4">
              Not enough data to detect patterns yet. Keep logging your tasks!
            </p>
          ) : (
            productivityPatterns.map((pattern, index) => (
              <div
                key={index}
                className="p-4 bg-blue-50 border border-blue-200 rounded-lg"
              >
                <div className="flex items-start justify-between mb-2">
                  <h4 className="font-semibold text-blue-900">{pattern.label}</h4>
                  <Badge variant="outline" className="text-xs">
                    {Math.round(pattern.confidence * 100)}% confidence
                  </Badge>
                </div>
                
                <p className="text-sm text-blue-800 mb-2">
                  {pattern.description}
                </p>
                
                <div className="text-xs font-medium text-blue-700 bg-blue-100 p-2 rounded">
                  üí° {pattern.recommendation}
                </div>

                {pattern.data.bestDays.length > 0 && (
                  <div className="mt-3 text-xs text-blue-600">
                    <strong>Best days:</strong> {pattern.data.bestDays.join(', ')}
                  </div>
                )}

                {pattern.data.bestHours.length > 0 && (
                  <div className="text-xs text-blue-600">
                    <strong>Peak hours:</strong> {pattern.data.bestHours.map(h => `${h}:00`).join(', ')}
                  </div>
                )}
              </div>
            ))
          )}
        </CardContent>
      </Card>
    </div>
  );
};
```

Create `components/analytics/ProductivityTrends.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { useAnalyticsStore } from '@/lib/stores/analyticsStore';
import { 
  LineChart, 
  Line, 
  XAxis, 
  YAxis, 
  CartesianGrid, 
  Tooltip, 
  ResponsiveContainer,
  AreaChart,
  Area
} from 'recharts';

export const ProductivityTrends: React.FC = () => {
  const { dailyProductivity } = useAnalyticsStore();

  const data = dailyProductivity.map(day => ({
    date: new Date(day.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
    completionRate: day.completionRate,
    productivity: day.productivityScore,
    completed: day.completedTasks,
    timeSpent: day.timeSpent
  }));

  return (
    <div className="space-y-6">
      {/* Completion Rate Trend */}
      <Card>
        <CardHeader>
          <CardTitle>Completion Rate Trend</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <AreaChart data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" tick={{ fontSize: 12 }} />
                <YAxis tick={{ fontSize: 12 }} />
                <Tooltip 
                  formatter={(value: any, name: string) => [
                    `${value.toFixed(1)}%`, 
                    'Completion Rate'
                  ]}
                />
                <Area 
                  type="monotone" 
                  dataKey="completionRate" 
                  stroke="#3b82f6" 
                  fill="#3b82f6" 
                  fillOpacity={0.3}
                />
              </AreaChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Productivity Score Trend */}
      <Card>
        <CardHeader>
          <CardTitle>Productivity Score Over Time</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" tick={{ fontSize: 12 }} />
                <YAxis tick={{ fontSize: 12 }} />
                <Tooltip 
                  formatter={(value: any, name: string) => [
                    Math.round(value), 
                    'Productivity Score'
                  ]}
                />
                <Line 
                  type="monotone" 
                  dataKey="productivity" 
                  stroke="#10b981" 
                  strokeWidth={2}
                  dot={{ fill: '#10b981', strokeWidth: 2, r: 4 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>

      {/* Daily Activity */}
      <Card>
        <CardHeader>
          <CardTitle>Daily Activity</CardTitle>
        </CardHeader>
        <CardContent>
          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={data}>
                <CartesianGrid strokeDasharray="3 3" />
                <XAxis dataKey="date" tick={{ fontSize: 12 }} />
                <YAxis yAxisId="left" tick={{ fontSize: 12 }} />
                <YAxis yAxisId="right" orientation="right" tick={{ fontSize: 12 }} />
                <Tooltip 
                  formatter={(value: any, name: string) => [
                    name === 'completed' ? `${value} tasks` : `${value} min`,
                    name === 'completed' ? 'Tasks Completed' : 'Time Spent'
                  ]}
                />
                <Line 
                  yAxisId="left"
                  type="monotone" 
                  dataKey="completed" 
                  stroke="#8b5cf6" 
                  strokeWidth={2}
                />
                <Line 
                  yAxisId="right"
                  type="monotone" 
                  dataKey="timeSpent" 
                  stroke="#f59e0b" 
                  strokeWidth={2}
                  strokeDasharray="5 5"
                />
              </LineChart>
            </ResponsiveContainer>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};
```

### 6. API Routes for Analytics

Create `app/api/analytics/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const period = searchParams.get('period') || 'week';
    const startDate = searchParams.get('startDate');
    const endDate = searchParams.get('endDate');

    // Get date range based on period
    const dateRange = getDateRange(period, startDate, endDate);

    // Fetch analytics data using SQL aggregations
    const analytics = await fetchAnalyticsData(supabase, user.id, dateRange);

    return NextResponse.json(analytics);
  } catch (error) {
    return NextResponse.json({ error: 'Failed to fetch analytics' }, { status: 500 });
  }
}

function getDateRange(period: string, startDate?: string | null, endDate?: string | null) {
  const now = new Date();
  
  if (startDate && endDate) {
    return { start: startDate, end: endDate };
  }

  switch (period) {
    case 'today':
      return {
        start: new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString(),
        end: now.toISOString()
      };
    case 'week':
      const weekStart = new Date(now);
      weekStart.setDate(now.getDate() - now.getDay());
      return {
        start: weekStart.toISOString(),
        end: now.toISOString()
      };
    case 'month':
      const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
      return {
        start: monthStart.toISOString(),
        end: now.toISOString()
      };
    default:
      const defaultStart = new Date(now);
      defaultStart.setDate(now.getDate() - 7);
      return {
        start: defaultStart.toISOString(),
        end: now.toISOString()
      };
  }
}

async function fetchAnalyticsData(supabase: any, userId: string, dateRange: any) {
  // Basic task statistics
  const { data: taskStats } = await supabase
    .rpc('get_task_statistics', {
      user_id_param: userId,
      start_date_param: dateRange.start,
      end_date_param: dateRange.end
    });

  // Time-of-day analytics
  const { data: timeAnalytics } = await supabase
    .rpc('get_time_of_day_analytics', {
      user_id_param: userId,
      start_date_param: dateRange.start,
      end_date_param: dateRange.end
    });

  // Project analytics
  const { data: projectStats } = await supabase
    .rpc('get_project_analytics', {
      user_id_param: userId,
      start_date_param: dateRange.start,
      end_date_param: dateRange.end
    });

  return {
    taskStats: taskStats || [],
    timeAnalytics: timeAnalytics || [],
    projectStats: projectStats || []
  };
}
```

### 7. Database Views and Functions

Create SQL functions for analytics aggregation:

```sql
-- Function to get task statistics
CREATE OR REPLACE FUNCTION get_task_statistics(
  user_id_param UUID,
  start_date_param TIMESTAMP,
  end_date_param TIMESTAMP
)
RETURNS TABLE (
  total_tasks BIGINT,
  completed_tasks BIGINT,
  pending_tasks BIGINT,
  overdue_tasks BIGINT,
  avg_completion_time INTERVAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COUNT(*) AS total_tasks,
    COUNT(*) FILTER (WHERE completed = true) AS completed_tasks,
    COUNT(*) FILTER (WHERE completed = false AND (due_date IS NULL OR due_date >= NOW())) AS pending_tasks,
    COUNT(*) FILTER (WHERE completed = false AND due_date IS NOT NULL AND due_date < NOW()) AS overdue_tasks,
    AVG(completed_at - started_at) FILTER (WHERE completed = true AND started_at IS NOT NULL) AS avg_completion_time
  FROM tasks
  WHERE user_id = user_id_param
    AND created_at BETWEEN start_date_param AND end_date_param;
END;
$$ LANGUAGE plpgsql;

-- Function to get time-of-day analytics
CREATE OR REPLACE FUNCTION get_time_of_day_analytics(
  user_id_param UUID,
  start_date_param TIMESTAMP,
  end_date_param TIMESTAMP
)
RETURNS TABLE (
  hour_of_day INTEGER,
  completed_count BIGINT,
  avg_completion_rate NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    EXTRACT(HOUR FROM completed_at)::INTEGER AS hour_of_day,
    COUNT(*) AS completed_count,
    (COUNT(*) * 100.0 / NULLIF(COUNT(*) OVER (PARTITION BY DATE(completed_at)), 0)) AS avg_completion_rate
  FROM tasks
  WHERE user_id = user_id_param
    AND completed = true
    AND completed_at IS NOT NULL
    AND completed_at BETWEEN start_date_param AND end_date_param
  GROUP BY EXTRACT(HOUR FROM completed_at)
  ORDER BY hour_of_day;
END;
$$ LANGUAGE plpgsql;

-- Function to get project analytics
CREATE OR REPLACE FUNCTION get_project_analytics(
  user_id_param UUID,
  start_date_param TIMESTAMP,
  end_date_param TIMESTAMP
)
RETURNS TABLE (
  project_id UUID,
  project_name TEXT,
  total_tasks BIGINT,
  completed_tasks BIGINT,
  completion_rate NUMERIC,
  avg_time_per_task INTERVAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    COALESCE(t.project_id, '00000000-0000-0000-0000-000000000000'::UUID) AS project_id,
    COALESCE(p.name, 'No Project') AS project_name,
    COUNT(*) AS total_tasks,
    COUNT(*) FILTER (WHERE t.completed = true) AS completed_tasks,
    (COUNT(*) FILTER (WHERE t.completed = true) * 100.0 / COUNT(*)) AS completion_rate,
    AVG(t.completed_at - t.started_at) FILTER (WHERE t.completed = true AND t.started_at IS NOT NULL) AS avg_time_per_task
  FROM tasks t
  LEFT JOIN projects p ON t.project_id = p.id
  WHERE t.user_id = user_id_param
    AND t.created_at BETWEEN start_date_param AND end_date_param
  GROUP BY t.project_id, p.name
  ORDER BY total_tasks DESC;
END;
$$ LANGUAGE plpgsql;

-- View for daily productivity summary
CREATE OR REPLACE VIEW daily_productivity_summary AS
SELECT 
  user_id,
  DATE(created_at) as date,
  COUNT(*) as total_tasks,
  COUNT(*) FILTER (WHERE completed = true) as completed_tasks,
  (COUNT(*) FILTER (WHERE completed = true) * 100.0 / COUNT(*)) as completion_rate,
  SUM(estimated_duration) FILTER (WHERE completed = true) as total_time_spent,
  -- Simple productivity score calculation
  LEAST(100, 
    (COUNT(*) FILTER (WHERE completed = true) * 100.0 / COUNT(*)) * 0.7 + 
    LEAST(30, COUNT(*) FILTER (WHERE completed = true) * 3)
  ) as productivity_score
FROM tasks
GROUP BY user_id, DATE(created_at);
```

### 8. Performance Optimizations

Add database indexes for analytics queries:

```sql
-- Indexes for analytics performance
CREATE INDEX IF NOT EXISTS idx_tasks_user_created_at ON tasks(user_id, created_at);
CREATE INDEX IF NOT EXISTS idx_tasks_user_completed_at ON tasks(user_id, completed_at) WHERE completed = true;
CREATE INDEX IF NOT EXISTS idx_tasks_user_project ON tasks(user_id, project_id);
CREATE INDEX IF NOT EXISTS idx_tasks_due_date ON tasks(due_date) WHERE due_date IS NOT NULL;
CREATE INDEX IF NOT EXISTS idx_tasks_completed_status ON tasks(completed, user_id);

-- Partial indexes for common queries
CREATE INDEX IF NOT EXISTS idx_tasks_pending ON tasks(user_id, created_at) 
WHERE completed = false;

CREATE INDEX IF NOT EXISTS idx_tasks_overdue ON tasks(user_id, due_date) 
WHERE completed = false AND due_date < NOW();
```

## Dependencies
- [ ] Task 004 completed (Task data available)
- [ ] Database functions for aggregations

## Effort Estimate
- Size: M
- Hours: 5
- Parallel: true

## Definition of Done
- [ ] All charts rendering correctly
- [ ] Analytics calculations accurate
- [ ] Export functionality working
- [ ] Mobile responsive design
- [ ] Performance optimized (< 1s load)
