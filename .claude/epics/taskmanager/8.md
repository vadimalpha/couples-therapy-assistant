---
name: Smart Prioritization
status: open
created: 2025-08-26T18:29:07Z
updated: 2025-08-26T20:52:21Z
github: https://github.com/vadimalpha/taskmanager/issues/8
depends_on: [004]
parallel: true
conflicts_with: []
---

# Task: Smart Prioritization

## Description
Implement intelligent task prioritization using the Eisenhower Matrix (urgent/important), due dates, and simple heuristics for suggesting daily focus tasks.

## Acceptance Criteria
- [ ] Eisenhower Matrix categorization (4 quadrants)
- [ ] Automatic priority calculation based on due date proximity
- [ ] Daily task suggestions based on priorities
- [ ] Manual priority override option
- [ ] Visual priority indicators (colors/badges)
- [ ] Smart rescheduling of overdue tasks
- [ ] Time-of-day suggestions (energy-based)
- [ ] Priority explanation tooltips

## Detailed Implementation Specifications

### 1. Priority Types and Constants

Create `lib/types/priority.ts`:
```typescript
export enum PriorityLevel {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  URGENT = 'urgent'
}

export enum EisenhowerQuadrant {
  DO = 'do', // Important & Urgent
  SCHEDULE = 'schedule', // Important & Not Urgent
  DELEGATE = 'delegate', // Not Important & Urgent
  DELETE = 'delete' // Not Important & Not Urgent
}

export enum EnergyLevel {
  PEAK = 'peak', // 9-11 AM, best for complex tasks
  HIGH = 'high', // 2-4 PM, good for focused work
  MEDIUM = 'medium', // Other times, routine tasks
  LOW = 'low' // Evening, easy tasks only
}

export interface PriorityScore {
  overall: number; // 0-100
  urgency: number; // 0-40
  importance: number; // 0-40
  context: number; // 0-20 (energy, location, etc.)
  quadrant: EisenhowerQuadrant;
  level: PriorityLevel;
  explanation: string;
}

export interface TaskPriority {
  id: string;
  taskId: string;
  score: PriorityScore;
  manualOverride?: PriorityLevel;
  suggestedTimeSlot?: {
    start: Date;
    end: Date;
    energyLevel: EnergyLevel;
  };
  lastCalculated: Date;
  factors: PriorityFactor[];
}

export interface PriorityFactor {
  name: string;
  weight: number;
  value: number;
  impact: number;
  explanation: string;
}

export interface DailySuggestion {
  taskId: string;
  priority: number;
  timeSlot: string; // '09:00-10:30'
  energyMatch: number; // 0-1
  reasoning: string;
  estimatedDuration: number; // minutes
}

export interface UserEnergyPattern {
  userId: string;
  peakHours: number[]; // [9, 10, 11]
  highHours: number[]; // [14, 15, 16]
  mediumHours: number[];
  lowHours: number[];
  lastUpdated: Date;
  confidence: number; // 0-1
}
```

### 2. Priority Calculation Engine

Create `lib/prioritization/engine.ts`:
```typescript
import { Task } from '../types/task';
import { 
  PriorityScore, 
  EisenhowerQuadrant, 
  PriorityLevel, 
  PriorityFactor,
  UserEnergyPattern,
  EnergyLevel 
} from '../types/priority';
import { differenceInDays, differenceInHours, isAfter, isBefore } from 'date-fns';

export class PrioritizationEngine {
  private weights = {
    urgency: 0.4,
    importance: 0.4,
    context: 0.2
  };

  calculatePriority(
    task: Task, 
    userPreferences: any,
    energyPattern?: UserEnergyPattern
  ): PriorityScore {
    const urgencyScore = this.calculateUrgencyScore(task);
    const importanceScore = this.calculateImportanceScore(task, userPreferences);
    const contextScore = this.calculateContextScore(task, energyPattern);
    
    const overall = Math.round(
      urgencyScore * this.weights.urgency +
      importanceScore * this.weights.importance +
      contextScore * this.weights.context
    );

    const quadrant = this.determineQuadrant(urgencyScore, importanceScore);
    const level = this.determinePriorityLevel(overall);
    const explanation = this.generateExplanation(urgencyScore, importanceScore, contextScore, quadrant);

    return {
      overall,
      urgency: urgencyScore,
      importance: importanceScore,
      context: contextScore,
      quadrant,
      level,
      explanation
    };
  }

  private calculateUrgencyScore(task: Task): number {
    const factors: PriorityFactor[] = [];
    let score = 0;

    // Due date proximity (0-25 points)
    if (task.dueDate) {
      const daysUntilDue = differenceInDays(new Date(task.dueDate), new Date());
      const hoursUntilDue = differenceInHours(new Date(task.dueDate), new Date());
      
      if (hoursUntilDue < 0) {
        // Overdue
        score += 25;
        factors.push({
          name: 'Overdue',
          weight: 0.625,
          value: 40,
          impact: 25,
          explanation: `Task is ${Math.abs(daysUntilDue)} days overdue`
        });
      } else if (hoursUntilDue <= 24) {
        // Due today
        score += 20;
        factors.push({
          name: 'Due Today',
          weight: 0.5,
          value: 40,
          impact: 20,
          explanation: 'Task is due within 24 hours'
        });
      } else if (daysUntilDue <= 3) {
        // Due within 3 days
        score += 15;
        factors.push({
          name: 'Due Soon',
          weight: 0.375,
          value: 40,
          impact: 15,
          explanation: `Task is due in ${daysUntilDue} days`
        });
      } else if (daysUntilDue <= 7) {
        // Due within a week
        score += 10;
        factors.push({
          name: 'Due This Week',
          weight: 0.25,
          value: 40,
          impact: 10,
          explanation: `Task is due in ${daysUntilDue} days`
        });
      }
    }

    // Time-sensitive indicators (0-10 points)
    if (task.tags?.some(tag => ['urgent', 'asap', 'emergency'].includes(tag.toLowerCase()))) {
      score += 10;
      factors.push({
        name: 'Urgent Tag',
        weight: 0.25,
        value: 40,
        impact: 10,
        explanation: 'Task is tagged as urgent'
      });
    }

    // Blocking other tasks (0-5 points)
    if (task.dependencies && task.dependencies.length > 0) {
      score += 5;
      factors.push({
        name: 'Blocking Tasks',
        weight: 0.125,
        value: 40,
        impact: 5,
        explanation: `Task blocks ${task.dependencies.length} other tasks`
      });
    }

    return Math.min(score, 40);
  }

  private calculateImportanceScore(task: Task, userPreferences: any): number {
    const factors: PriorityFactor[] = [];
    let score = 0;

    // User-defined importance (0-15 points)
    if (task.importance) {
      const importanceMap = { low: 5, medium: 10, high: 15 };
      score += importanceMap[task.importance as keyof typeof importanceMap] || 0;
      factors.push({
        name: 'User Importance',
        weight: 0.375,
        value: task.importance === 'high' ? 40 : task.importance === 'medium' ? 25 : 10,
        impact: importanceMap[task.importance as keyof typeof importanceMap] || 0,
        explanation: `User marked as ${task.importance} importance`
      });
    }

    // Project importance (0-10 points)
    if (task.projectId && userPreferences?.projectPriorities?.[task.projectId]) {
      const projectPriority = userPreferences.projectPriorities[task.projectId];
      const projectScore = projectPriority === 'high' ? 10 : projectPriority === 'medium' ? 5 : 2;
      score += projectScore;
      factors.push({
        name: 'Project Priority',
        weight: 0.25,
        value: projectPriority === 'high' ? 40 : 20,
        impact: projectScore,
        explanation: `Part of ${projectPriority} priority project`
      });
    }

    // Goal alignment (0-10 points)
    if (task.tags?.some(tag => userPreferences?.goalTags?.includes(tag))) {
      score += 10;
      factors.push({
        name: 'Goal Alignment',
        weight: 0.25,
        value: 40,
        impact: 10,
        explanation: 'Task aligns with user goals'
      });
    }

    // Estimated effort vs impact (0-5 points)
    if (task.estimatedDuration) {
      const effortHours = task.estimatedDuration / 60;
      if (effortHours <= 0.5) {
        // Quick wins get bonus points
        score += 5;
        factors.push({
          name: 'Quick Win',
          weight: 0.125,
          value: 40,
          impact: 5,
          explanation: 'Task can be completed quickly (under 30 minutes)'
        });
      }
    }

    return Math.min(score, 40);
  }

  private calculateContextScore(task: Task, energyPattern?: UserEnergyPattern): number {
    let score = 0;
    const currentHour = new Date().getHours();

    // Energy level match (0-10 points)
    if (energyPattern && task.energyRequired) {
      const currentEnergyLevel = this.getCurrentEnergyLevel(currentHour, energyPattern);
      const taskEnergyRequirement = task.energyRequired as EnergyLevel;
      
      if (this.isEnergyMatch(currentEnergyLevel, taskEnergyRequirement)) {
        score += 10;
      } else if (this.isPartialEnergyMatch(currentEnergyLevel, taskEnergyRequirement)) {
        score += 5;
      }
    }

    // Time of day suitability (0-5 points)
    if (task.preferredTimeSlots) {
      const isPreferredTime = task.preferredTimeSlots.some((slot: any) => 
        currentHour >= slot.start && currentHour <= slot.end
      );
      if (isPreferredTime) {
        score += 5;
      }
    }

    // Location context (0-5 points)
    if (task.location && task.location === 'current_location') {
      score += 5;
    }

    return Math.min(score, 20);
  }

  private determineQuadrant(urgency: number, importance: number): EisenhowerQuadrant {
    const isUrgent = urgency >= 20;
    const isImportant = importance >= 20;

    if (isImportant && isUrgent) return EisenhowerQuadrant.DO;
    if (isImportant && !isUrgent) return EisenhowerQuadrant.SCHEDULE;
    if (!isImportant && isUrgent) return EisenhowerQuadrant.DELEGATE;
    return EisenhowerQuadrant.DELETE;
  }

  private determinePriorityLevel(overall: number): PriorityLevel {
    if (overall >= 80) return PriorityLevel.URGENT;
    if (overall >= 60) return PriorityLevel.HIGH;
    if (overall >= 30) return PriorityLevel.MEDIUM;
    return PriorityLevel.LOW;
  }

  private generateExplanation(
    urgency: number, 
    importance: number, 
    context: number, 
    quadrant: EisenhowerQuadrant
  ): string {
    const explanations = [];
    
    if (urgency >= 25) explanations.push('Very time-sensitive');
    else if (urgency >= 15) explanations.push('Moderately urgent');
    
    if (importance >= 25) explanations.push('High strategic value');
    else if (importance >= 15) explanations.push('Moderately important');
    
    if (context >= 15) explanations.push('Perfect timing');
    else if (context >= 10) explanations.push('Good timing');

    const quadrantDescriptions = {
      [EisenhowerQuadrant.DO]: 'Do first - urgent and important',
      [EisenhowerQuadrant.SCHEDULE]: 'Schedule - important but not urgent',
      [EisenhowerQuadrant.DELEGATE]: 'Delegate - urgent but not important',
      [EisenhowerQuadrant.DELETE]: 'Eliminate - neither urgent nor important'
    };

    explanations.push(quadrantDescriptions[quadrant]);
    
    return explanations.join('. ');
  }

  private getCurrentEnergyLevel(hour: number, pattern: UserEnergyPattern): EnergyLevel {
    if (pattern.peakHours.includes(hour)) return EnergyLevel.PEAK;
    if (pattern.highHours.includes(hour)) return EnergyLevel.HIGH;
    if (pattern.mediumHours.includes(hour)) return EnergyLevel.MEDIUM;
    return EnergyLevel.LOW;
  }

  private isEnergyMatch(current: EnergyLevel, required: EnergyLevel): boolean {
    const energyLevels = [EnergyLevel.LOW, EnergyLevel.MEDIUM, EnergyLevel.HIGH, EnergyLevel.PEAK];
    const currentIndex = energyLevels.indexOf(current);
    const requiredIndex = energyLevels.indexOf(required);
    return currentIndex >= requiredIndex;
  }

  private isPartialEnergyMatch(current: EnergyLevel, required: EnergyLevel): boolean {
    const energyLevels = [EnergyLevel.LOW, EnergyLevel.MEDIUM, EnergyLevel.HIGH, EnergyLevel.PEAK];
    const currentIndex = energyLevels.indexOf(current);
    const requiredIndex = energyLevels.indexOf(required);
    return Math.abs(currentIndex - requiredIndex) === 1;
  }
}
```

### 3. Daily Suggestions Algorithm

Create `lib/prioritization/suggestions.ts`:
```typescript
import { Task } from '../types/task';
import { DailySuggestion, UserEnergyPattern, EnergyLevel } from '../types/priority';
import { PrioritizationEngine } from './engine';
import { addMinutes, format, startOfDay, endOfDay, isWithinInterval } from 'date-fns';

export class DailySuggestionEngine {
  private prioritizationEngine: PrioritizationEngine;

  constructor() {
    this.prioritizationEngine = new PrioritizationEngine();
  }

  generateDailySuggestions(
    tasks: Task[],
    userPreferences: any,
    energyPattern: UserEnergyPattern,
    workingHours = { start: 9, end: 17 },
    maxTasks = 8
  ): DailySuggestion[] {
    // Filter to today's relevant tasks
    const todayStart = startOfDay(new Date());
    const todayEnd = endOfDay(new Date());
    
    const availableTasks = tasks.filter(task => 
      !task.completed &&
      (!task.scheduledDate || isWithinInterval(new Date(task.scheduledDate), { start: todayStart, end: todayEnd })) &&
      (!task.dueDate || new Date(task.dueDate) >= todayStart)
    );

    // Calculate priorities for all tasks
    const prioritizedTasks = availableTasks
      .map(task => ({
        task,
        priority: this.prioritizationEngine.calculatePriority(task, userPreferences, energyPattern)
      }))
      .sort((a, b) => b.priority.overall - a.priority.overall);

    // Generate time slots based on energy pattern
    const timeSlots = this.generateTimeSlots(workingHours, energyPattern);
    
    // Match tasks to optimal time slots
    const suggestions: DailySuggestion[] = [];
    let usedTime = 0;
    const maxWorkingMinutes = (workingHours.end - workingHours.start) * 60;

    for (const { task, priority } of prioritizedTasks) {
      if (suggestions.length >= maxTasks) break;
      
      const duration = task.estimatedDuration || 60;
      if (usedTime + duration > maxWorkingMinutes * 0.8) break; // Leave 20% buffer

      const optimalSlot = this.findOptimalTimeSlot(
        task,
        timeSlots,
        duration,
        energyPattern,
        suggestions
      );

      if (optimalSlot) {
        suggestions.push({
          taskId: task.id,
          priority: priority.overall,
          timeSlot: optimalSlot.timeSlot,
          energyMatch: optimalSlot.energyMatch,
          reasoning: this.generateReasoning(task, priority, optimalSlot),
          estimatedDuration: duration
        });

        usedTime += duration;
      }
    }

    return suggestions.sort((a, b) => {
      const timeA = parseInt(a.timeSlot.split(':')[0]);
      const timeB = parseInt(b.timeSlot.split(':')[0]);
      return timeA - timeB;
    });
  }

  private generateTimeSlots(
    workingHours: { start: number; end: number },
    energyPattern: UserEnergyPattern
  ) {
    const slots = [];
    
    for (let hour = workingHours.start; hour < workingHours.end; hour++) {
      const energyLevel = this.getEnergyLevelForHour(hour, energyPattern);
      
      // Create 30-minute slots
      slots.push({
        start: hour,
        end: hour + 0.5,
        energyLevel,
        timeSlot: `${hour.toString().padStart(2, '0')}:00-${hour.toString().padStart(2, '0')}:30`
      });
      
      slots.push({
        start: hour + 0.5,
        end: hour + 1,
        energyLevel,
        timeSlot: `${hour.toString().padStart(2, '0')}:30-${(hour + 1).toString().padStart(2, '0')}:00`
      });
    }
    
    return slots;
  }

  private findOptimalTimeSlot(
    task: Task,
    timeSlots: any[],
    duration: number,
    energyPattern: UserEnergyPattern,
    existingSuggestions: DailySuggestion[]
  ) {
    const requiredSlots = Math.ceil(duration / 30);
    const usedSlots = new Set(existingSuggestions.map(s => s.timeSlot));

    // Find best consecutive slots
    for (let i = 0; i <= timeSlots.length - requiredSlots; i++) {
      const candidateSlots = timeSlots.slice(i, i + requiredSlots);
      
      // Check if all slots are available
      const isAvailable = candidateSlots.every(slot => !usedSlots.has(slot.timeSlot));
      if (!isAvailable) continue;

      // Calculate energy match
      const taskEnergyRequirement = task.energyRequired as EnergyLevel || EnergyLevel.MEDIUM;
      const avgEnergyLevel = this.getAverageEnergyLevel(candidateSlots.map(s => s.energyLevel));
      const energyMatch = this.calculateEnergyMatch(avgEnergyLevel, taskEnergyRequirement);

      // Prefer earlier slots for high-priority tasks
      const timePreference = task.preferredTimeSlots ? 
        this.checkTimePreference(candidateSlots, task.preferredTimeSlots) : 0.5;

      const score = energyMatch * 0.7 + timePreference * 0.3;

      if (score >= 0.6) { // Minimum acceptable match
        return {
          timeSlot: `${candidateSlots[0].timeSlot.split('-')[0]}-${candidateSlots[candidateSlots.length - 1].timeSlot.split('-')[1]}`,
          energyMatch: energyMatch,
          score: score
        };
      }
    }

    return null;
  }

  private generateReasoning(task: Task, priority: any, slot: any): string {
    const reasons = [];
    
    if (priority.overall >= 80) {
      reasons.push('Highest priority task');
    } else if (priority.overall >= 60) {
      reasons.push('High priority');
    }
    
    if (slot.energyMatch >= 0.8) {
      reasons.push('Perfect energy level match');
    } else if (slot.energyMatch >= 0.6) {
      reasons.push('Good energy level for this task');
    }
    
    if (priority.urgency >= 25) {
      reasons.push('Time-sensitive');
    }
    
    if (priority.importance >= 25) {
      reasons.push('High strategic value');
    }

    return reasons.join(', ');
  }

  private getEnergyLevelForHour(hour: number, pattern: UserEnergyPattern): EnergyLevel {
    if (pattern.peakHours.includes(hour)) return EnergyLevel.PEAK;
    if (pattern.highHours.includes(hour)) return EnergyLevel.HIGH;
    if (pattern.mediumHours.includes(hour)) return EnergyLevel.MEDIUM;
    return EnergyLevel.LOW;
  }

  private getAverageEnergyLevel(levels: EnergyLevel[]): EnergyLevel {
    const energyValues = {
      [EnergyLevel.LOW]: 1,
      [EnergyLevel.MEDIUM]: 2,
      [EnergyLevel.HIGH]: 3,
      [EnergyLevel.PEAK]: 4
    };

    const average = levels.reduce((sum, level) => sum + energyValues[level], 0) / levels.length;
    
    if (average >= 3.5) return EnergyLevel.PEAK;
    if (average >= 2.5) return EnergyLevel.HIGH;
    if (average >= 1.5) return EnergyLevel.MEDIUM;
    return EnergyLevel.LOW;
  }

  private calculateEnergyMatch(available: EnergyLevel, required: EnergyLevel): number {
    const energyLevels = [EnergyLevel.LOW, EnergyLevel.MEDIUM, EnergyLevel.HIGH, EnergyLevel.PEAK];
    const availableIndex = energyLevels.indexOf(available);
    const requiredIndex = energyLevels.indexOf(required);
    
    if (availableIndex >= requiredIndex) {
      return 1.0 - (availableIndex - requiredIndex) * 0.1;
    } else {
      return Math.max(0, 1.0 - (requiredIndex - availableIndex) * 0.3);
    }
  }

  private checkTimePreference(slots: any[], preferredSlots: any[]): number {
    // Implementation for checking if slots match user's preferred time preferences
    return 0.5; // Default neutral score
  }
}
```

### 4. Priority Store

Create `lib/stores/priorityStore.ts`:
```typescript
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { 
  TaskPriority, 
  DailySuggestion, 
  UserEnergyPattern, 
  EisenhowerQuadrant,
  PriorityLevel 
} from '../types/priority';
import { PrioritizationEngine } from '../prioritization/engine';
import { DailySuggestionEngine } from '../prioritization/suggestions';

interface PriorityState {
  // Data
  taskPriorities: Map<string, TaskPriority>;
  dailySuggestions: DailySuggestion[];
  userEnergyPattern: UserEnergyPattern | null;
  
  // UI State
  selectedQuadrant: EisenhowerQuadrant | null;
  showPriorityExplanations: boolean;
  autoCalculatePriorities: boolean;
  
  // Loading States
  isCalculatingPriorities: boolean;
  isGeneratingSuggestions: boolean;
  
  // Actions
  calculateTaskPriority: (taskId: string) => Promise<void>;
  calculateAllPriorities: () => Promise<void>;
  updateManualPriority: (taskId: string, priority: PriorityLevel) => Promise<void>;
  generateDailySuggestions: () => Promise<void>;
  setEnergyPattern: (pattern: UserEnergyPattern) => void;
  setSelectedQuadrant: (quadrant: EisenhowerQuadrant | null) => void;
  togglePriorityExplanations: () => void;
  rescheduleOverdueTasks: () => Promise<void>;
  
  // Getters
  getTasksByQuadrant: (quadrant: EisenhowerQuadrant) => TaskPriority[];
  getTasksByPriorityLevel: (level: PriorityLevel) => TaskPriority[];
  getPriorityExplanation: (taskId: string) => string;
}

export const usePriorityStore = create<PriorityState>()(
  devtools(
    persist(
      (set, get) => {
        const prioritizationEngine = new PrioritizationEngine();
        const suggestionEngine = new DailySuggestionEngine();

        return {
          // Initial State
          taskPriorities: new Map(),
          dailySuggestions: [],
          userEnergyPattern: null,
          selectedQuadrant: null,
          showPriorityExplanations: true,
          autoCalculatePriorities: true,
          isCalculatingPriorities: false,
          isGeneratingSuggestions: false,

          // Actions
          calculateTaskPriority: async (taskId: string) => {
            set({ isCalculatingPriorities: true });
            
            try {
              // Get task data from task store
              const taskStore = useTaskStore.getState();
              const task = taskStore.tasks.find(t => t.id === taskId);
              
              if (!task) {
                throw new Error(`Task ${taskId} not found`);
              }

              const userPreferences = {}; // Get from user preferences
              const { userEnergyPattern } = get();
              
              const priorityScore = prioritizationEngine.calculatePriority(
                task,
                userPreferences,
                userEnergyPattern || undefined
              );

              const taskPriority: TaskPriority = {
                id: `priority_${taskId}`,
                taskId,
                score: priorityScore,
                lastCalculated: new Date(),
                factors: [] // Populate with actual factors
              };

              set(state => ({
                taskPriorities: new Map(state.taskPriorities.set(taskId, taskPriority))
              }));

              // Save to database
              await fetch('/api/priorities', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(taskPriority)
              });

            } catch (error) {
              console.error('Failed to calculate priority:', error);
            } finally {
              set({ isCalculatingPriorities: false });
            }
          },

          calculateAllPriorities: async () => {
            set({ isCalculatingPriorities: true });
            
            try {
              const taskStore = useTaskStore.getState();
              const incompleteTasks = taskStore.tasks.filter(t => !t.completed);
              
              for (const task of incompleteTasks) {
                await get().calculateTaskPriority(task.id);
              }

              // Batch update in database
              const priorities = Array.from(get().taskPriorities.values());
              await fetch('/api/priorities/batch', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(priorities)
              });

            } catch (error) {
              console.error('Failed to calculate all priorities:', error);
            } finally {
              set({ isCalculatingPriorities: false });
            }
          },

          updateManualPriority: async (taskId: string, priority: PriorityLevel) => {
            try {
              const currentPriority = get().taskPriorities.get(taskId);
              if (!currentPriority) return;

              const updatedPriority = {
                ...currentPriority,
                manualOverride: priority,
                lastCalculated: new Date()
              };

              set(state => ({
                taskPriorities: new Map(state.taskPriorities.set(taskId, updatedPriority))
              }));

              // Update in database
              await fetch(`/api/priorities/${taskId}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ manualOverride: priority })
              });

            } catch (error) {
              console.error('Failed to update manual priority:', error);
            }
          },

          generateDailySuggestions: async () => {
            set({ isGeneratingSuggestions: true });
            
            try {
              const taskStore = useTaskStore.getState();
              const userPreferences = {}; // Get from user preferences
              const { userEnergyPattern } = get();

              if (!userEnergyPattern) {
                // Use default energy pattern
                const defaultPattern: UserEnergyPattern = {
                  userId: 'current_user',
                  peakHours: [9, 10, 11],
                  highHours: [14, 15, 16],
                  mediumHours: [8, 12, 13, 17],
                  lowHours: [18, 19, 20],
                  lastUpdated: new Date(),
                  confidence: 0.5
                };
                set({ userEnergyPattern: defaultPattern });
              }

              const suggestions = suggestionEngine.generateDailySuggestions(
                taskStore.tasks,
                userPreferences,
                userEnergyPattern || get().userEnergyPattern!
              );

              set({ dailySuggestions: suggestions });

              // Save suggestions to database
              await fetch('/api/suggestions/daily', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(suggestions)
              });

            } catch (error) {
              console.error('Failed to generate daily suggestions:', error);
            } finally {
              set({ isGeneratingSuggestions: false });
            }
          },

          setEnergyPattern: (pattern: UserEnergyPattern) => {
            set({ userEnergyPattern: pattern });
          },

          setSelectedQuadrant: (quadrant: EisenhowerQuadrant | null) => {
            set({ selectedQuadrant: quadrant });
          },

          togglePriorityExplanations: () => {
            set(state => ({ showPriorityExplanations: !state.showPriorityExplanations }));
          },

          rescheduleOverdueTasks: async () => {
            try {
              const taskStore = useTaskStore.getState();
              const overdueTasks = taskStore.tasks.filter(task => 
                task.dueDate && 
                new Date(task.dueDate) < new Date() &&
                !task.completed
              );

              for (const task of overdueTasks) {
                // Reschedule logic - add 1 day to due date and recalculate priority
                const newDueDate = new Date(task.dueDate!);
                newDueDate.setDate(newDueDate.getDate() + 1);

                await taskStore.updateTask(task.id, {
                  dueDate: newDueDate.toISOString(),
                  rescheduled: true,
                  rescheduleReason: 'Automatic rescheduling of overdue task'
                });

                // Recalculate priority
                await get().calculateTaskPriority(task.id);
              }

            } catch (error) {
              console.error('Failed to reschedule overdue tasks:', error);
            }
          },

          // Getters
          getTasksByQuadrant: (quadrant: EisenhowerQuadrant) => {
            return Array.from(get().taskPriorities.values())
              .filter(priority => priority.score.quadrant === quadrant);
          },

          getTasksByPriorityLevel: (level: PriorityLevel) => {
            return Array.from(get().taskPriorities.values())
              .filter(priority => priority.manualOverride === level || priority.score.level === level);
          },

          getPriorityExplanation: (taskId: string) => {
            const priority = get().taskPriorities.get(taskId);
            return priority?.score.explanation || 'Priority not calculated';
          }
        };
      },
      {
        name: 'priority-store',
        partialize: (state) => ({
          taskPriorities: Array.from(state.taskPriorities.entries()),
          userEnergyPattern: state.userEnergyPattern,
          showPriorityExplanations: state.showPriorityExplanations,
          autoCalculatePriorities: state.autoCalculatePriorities
        }),
        onRehydrateStorage: () => (state) => {
          if (state?.taskPriorities) {
            state.taskPriorities = new Map(state.taskPriorities as any);
          }
        }
      }
    ),
    { name: 'PriorityStore' }
  )
);

// Helper hook for task priorities
export const useTaskPriority = (taskId: string) => {
  return usePriorityStore(state => state.taskPriorities.get(taskId));
};
```

### 5. Priority UI Components

Create `components/priority/PriorityBadge.tsx`:
```typescript
import React from 'react';
import { Badge } from '@/components/ui/badge';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { PriorityLevel, EisenhowerQuadrant } from '@/lib/types/priority';
import { Clock, AlertTriangle, Calendar, Target } from 'lucide-react';

interface PriorityBadgeProps {
  level: PriorityLevel;
  quadrant: EisenhowerQuadrant;
  score: number;
  explanation?: string;
  showExplanation?: boolean;
  size?: 'sm' | 'md' | 'lg';
}

const priorityConfig = {
  [PriorityLevel.URGENT]: {
    color: 'bg-red-500 text-white',
    icon: AlertTriangle,
    label: 'Urgent'
  },
  [PriorityLevel.HIGH]: {
    color: 'bg-orange-500 text-white',
    icon: Clock,
    label: 'High'
  },
  [PriorityLevel.MEDIUM]: {
    color: 'bg-yellow-500 text-white',
    icon: Calendar,
    label: 'Medium'
  },
  [PriorityLevel.LOW]: {
    color: 'bg-gray-400 text-white',
    icon: Target,
    label: 'Low'
  }
};

const quadrantConfig = {
  [EisenhowerQuadrant.DO]: {
    color: 'border-red-500',
    label: 'Do First',
    description: 'Important & Urgent'
  },
  [EisenhowerQuadrant.SCHEDULE]: {
    color: 'border-yellow-500',
    label: 'Schedule',
    description: 'Important & Not Urgent'
  },
  [EisenhowerQuadrant.DELEGATE]: {
    color: 'border-blue-500',
    label: 'Delegate',
    description: 'Urgent & Not Important'
  },
  [EisenhowerQuadrant.DELETE]: {
    color: 'border-gray-400',
    label: 'Eliminate',
    description: 'Not Important & Not Urgent'
  }
};

export const PriorityBadge: React.FC<PriorityBadgeProps> = ({
  level,
  quadrant,
  score,
  explanation,
  showExplanation = true,
  size = 'md'
}) => {
  const config = priorityConfig[level];
  const quadrantInfo = quadrantConfig[quadrant];
  const Icon = config.icon;

  const sizeClasses = {
    sm: 'text-xs px-1 py-0.5',
    md: 'text-sm px-2 py-1',
    lg: 'text-base px-3 py-1.5'
  };

  const badge = (
    <Badge 
      className={`${config.color} ${quadrantInfo.color} border-2 ${sizeClasses[size]} flex items-center gap-1`}
    >
      <Icon size={size === 'sm' ? 10 : size === 'md' ? 12 : 14} />
      <span>{config.label}</span>
      <span className="text-xs opacity-75">({score})</span>
    </Badge>
  );

  if (!showExplanation) {
    return badge;
  }

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          {badge}
        </TooltipTrigger>
        <TooltipContent side="bottom" className="max-w-sm">
          <div className="space-y-2">
            <div className="font-semibold">
              {quadrantInfo.label}: {quadrantInfo.description}
            </div>
            <div className="text-sm">
              Priority Score: {score}/100
            </div>
            {explanation && (
              <div className="text-sm text-gray-300">
                {explanation}
              </div>
            )}
          </div>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  );
};
```

Create `components/priority/EisenhowerMatrix.tsx`:
```typescript
import React, { useMemo } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { EisenhowerQuadrant, PriorityLevel } from '@/lib/types/priority';
import { usePriorityStore } from '@/lib/stores/priorityStore';
import { useTaskStore } from '@/lib/stores/taskStore';
import { AlertTriangle, Calendar, Users, Trash2 } from 'lucide-react';

interface EisenhowerMatrixProps {
  onTaskClick?: (taskId: string) => void;
  className?: string;
}

const quadrantConfig = {
  [EisenhowerQuadrant.DO]: {
    title: 'Do First',
    subtitle: 'Important & Urgent',
    color: 'bg-red-50 border-red-200',
    headerColor: 'bg-red-500 text-white',
    icon: AlertTriangle,
    description: 'Crisis, emergencies, deadline-driven projects'
  },
  [EisenhowerQuadrant.SCHEDULE]: {
    title: 'Schedule',
    subtitle: 'Important & Not Urgent',
    color: 'bg-yellow-50 border-yellow-200',
    headerColor: 'bg-yellow-500 text-white',
    icon: Calendar,
    description: 'Prevention, planning, development, research'
  },
  [EisenhowerQuadrant.DELEGATE]: {
    title: 'Delegate',
    subtitle: 'Urgent & Not Important',
    color: 'bg-blue-50 border-blue-200',
    headerColor: 'bg-blue-500 text-white',
    icon: Users,
    description: 'Interruptions, some emails, some meetings'
  },
  [EisenhowerQuadrant.DELETE]: {
    title: 'Eliminate',
    subtitle: 'Not Important & Not Urgent',
    color: 'bg-gray-50 border-gray-200',
    headerColor: 'bg-gray-500 text-white',
    icon: Trash2,
    description: 'Time wasters, excessive social media, busywork'
  }
};

export const EisenhowerMatrix: React.FC<EisenhowerMatrixProps> = ({
  onTaskClick,
  className = ''
}) => {
  const { taskPriorities, selectedQuadrant, setSelectedQuadrant } = usePriorityStore();
  const { tasks } = useTaskStore();

  const tasksByQuadrant = useMemo(() => {
    const result: Record<EisenhowerQuadrant, Array<{ task: any; priority: any }>> = {
      [EisenhowerQuadrant.DO]: [],
      [EisenhowerQuadrant.SCHEDULE]: [],
      [EisenhowerQuadrant.DELEGATE]: [],
      [EisenhowerQuadrant.DELETE]: []
    };

    Array.from(taskPriorities.entries()).forEach(([taskId, priority]) => {
      const task = tasks.find(t => t.id === taskId);
      if (task && !task.completed) {
        result[priority.score.quadrant].push({ task, priority });
      }
    });

    // Sort tasks within each quadrant by priority score
    Object.values(result).forEach(quadrantTasks => {
      quadrantTasks.sort((a, b) => b.priority.score.overall - a.priority.score.overall);
    });

    return result;
  }, [taskPriorities, tasks]);

  const renderQuadrant = (quadrant: EisenhowerQuadrant) => {
    const config = quadrantConfig[quadrant];
    const Icon = config.icon;
    const quadrantTasks = tasksByQuadrant[quadrant];
    const isSelected = selectedQuadrant === quadrant;

    return (
      <Card 
        key={quadrant}
        className={`${config.color} transition-all duration-200 ${
          isSelected ? 'ring-2 ring-blue-500 shadow-lg' : 'hover:shadow-md'
        } cursor-pointer`}
        onClick={() => setSelectedQuadrant(isSelected ? null : quadrant)}
      >
        <CardHeader className={`${config.headerColor} p-3`}>
          <CardTitle className="flex items-center gap-2 text-sm">
            <Icon size={16} />
            <div>
              <div className="font-semibold">{config.title}</div>
              <div className="text-xs opacity-90">{config.subtitle}</div>
            </div>
            <Badge variant="secondary" className="ml-auto">
              {quadrantTasks.length}
            </Badge>
          </CardTitle>
        </CardHeader>
        <CardContent className="p-3 space-y-2">
          <p className="text-xs text-gray-600 mb-3">
            {config.description}
          </p>
          
          <div className="space-y-1 max-h-32 overflow-y-auto">
            {quadrantTasks.slice(0, 5).map(({ task, priority }) => (
              <div
                key={task.id}
                className="flex items-center justify-between p-2 bg-white rounded border hover:bg-gray-50 cursor-pointer"
                onClick={(e) => {
                  e.stopPropagation();
                  onTaskClick?.(task.id);
                }}
              >
                <div className="flex-1 min-w-0">
                  <p className="text-sm font-medium truncate">{task.title}</p>
                  <p className="text-xs text-gray-500">
                    Score: {priority.score.overall}
                  </p>
                </div>
                <Badge 
                  variant={priority.score.level === PriorityLevel.URGENT ? 'destructive' : 'secondary'}
                  className="text-xs"
                >
                  {priority.score.level.toUpperCase()}
                </Badge>
              </div>
            ))}
            
            {quadrantTasks.length > 5 && (
              <Button
                variant="ghost"
                size="sm"
                className="w-full text-xs"
                onClick={(e) => {
                  e.stopPropagation();
                  setSelectedQuadrant(quadrant);
                }}
              >
                +{quadrantTasks.length - 5} more tasks
              </Button>
            )}
            
            {quadrantTasks.length === 0 && (
              <p className="text-xs text-gray-400 text-center py-4">
                No tasks in this quadrant
              </p>
            )}
          </div>
        </CardContent>
      </Card>
    );
  };

  return (
    <div className={`grid grid-cols-2 gap-4 ${className}`}>
      <div className="space-y-2">
        <div className="text-center text-sm font-medium text-gray-600">
          Important
        </div>
        {renderQuadrant(EisenhowerQuadrant.DO)}
        {renderQuadrant(EisenhowerQuadrant.SCHEDULE)}
      </div>
      <div className="space-y-2">
        <div className="text-center text-sm font-medium text-gray-600">
          Not Important
        </div>
        {renderQuadrant(EisenhowerQuadrant.DELEGATE)}
        {renderQuadrant(EisenhowerQuadrant.DELETE)}
      </div>
      
      {/* Axis Labels */}
      <div className="col-span-2 flex justify-between items-center mt-2">
        <div className="text-sm font-medium text-gray-600">Not Urgent</div>
        <div className="text-sm font-medium text-gray-600">Urgent</div>
      </div>
    </div>
  );
};
```

Create `components/priority/DailySuggestions.tsx`:
```typescript
import React, { useEffect } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { usePriorityStore } from '@/lib/stores/priorityStore';
import { useTaskStore } from '@/lib/stores/taskStore';
import { PriorityBadge } from './PriorityBadge';
import { 
  Clock, 
  Lightbulb, 
  Calendar, 
  RefreshCw,
  CheckCircle,
  Play,
  MoreHorizontal
} from 'lucide-react';
import { format } from 'date-fns';

interface DailySuggestionsProps {
  onTaskStart?: (taskId: string) => void;
  onTaskComplete?: (taskId: string) => void;
  className?: string;
}

export const DailySuggestions: React.FC<DailySuggestionsProps> = ({
  onTaskStart,
  onTaskComplete,
  className = ''
}) => {
  const { 
    dailySuggestions, 
    isGeneratingSuggestions, 
    generateDailySuggestions,
    taskPriorities 
  } = usePriorityStore();
  const { tasks, updateTask } = useTaskStore();

  useEffect(() => {
    // Generate suggestions on mount
    if (dailySuggestions.length === 0) {
      generateDailySuggestions();
    }
  }, []);

  const handleRefreshSuggestions = () => {
    generateDailySuggestions();
  };

  const handleTaskAction = async (taskId: string, action: 'start' | 'complete') => {
    if (action === 'start') {
      await updateTask(taskId, { 
        status: 'in_progress',
        startedAt: new Date().toISOString() 
      });
      onTaskStart?.(taskId);
    } else if (action === 'complete') {
      await updateTask(taskId, { 
        completed: true,
        completedAt: new Date().toISOString() 
      });
      onTaskComplete?.(taskId);
    }
  };

  if (isGeneratingSuggestions) {
    return (
      <Card className={className}>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Lightbulb className="h-5 w-5" />
            Today's Suggestions
          </CardTitle>
        </CardHeader>
        <CardContent className="space-y-3">
          {[...Array(4)].map((_, i) => (
            <div key={i} className="space-y-2">
              <Skeleton className="h-4 w-3/4" />
              <Skeleton className="h-3 w-1/2" />
            </div>
          ))}
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className={className}>
      <CardHeader className="flex flex-row items-center justify-between">
        <CardTitle className="flex items-center gap-2">
          <Lightbulb className="h-5 w-5" />
          Today's Suggestions
          <Badge variant="secondary">{dailySuggestions.length}</Badge>
        </CardTitle>
        <Button
          variant="ghost"
          size="sm"
          onClick={handleRefreshSuggestions}
          disabled={isGeneratingSuggestions}
        >
          <RefreshCw className={`h-4 w-4 ${isGeneratingSuggestions ? 'animate-spin' : ''}`} />
        </Button>
      </CardHeader>
      <CardContent>
        {dailySuggestions.length === 0 ? (
          <div className="text-center py-8 text-gray-500">
            <Lightbulb className="h-8 w-8 mx-auto mb-2 opacity-50" />
            <p>No suggestions available</p>
            <Button 
              variant="ghost" 
              size="sm" 
              onClick={handleRefreshSuggestions}
              className="mt-2"
            >
              Generate Suggestions
            </Button>
          </div>
        ) : (
          <div className="space-y-3">
            {dailySuggestions.map((suggestion) => {
              const task = tasks.find(t => t.id === suggestion.taskId);
              const priority = taskPriorities.get(suggestion.taskId);
              
              if (!task) return null;

              return (
                <div
                  key={suggestion.taskId}
                  className="border rounded-lg p-4 hover:bg-gray-50 transition-colors"
                >
                  <div className="flex items-start justify-between">
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-2">
                        <h3 className="font-medium truncate">{task.title}</h3>
                        {priority && (
                          <PriorityBadge
                            level={priority.score.level}
                            quadrant={priority.score.quadrant}
                            score={priority.score.overall}
                            size="sm"
                            showExplanation={false}
                          />
                        )}
                      </div>
                      
                      <div className="flex items-center gap-4 text-sm text-gray-600">
                        <div className="flex items-center gap-1">
                          <Clock className="h-4 w-4" />
                          <span>{suggestion.timeSlot}</span>
                        </div>
                        <div className="flex items-center gap-1">
                          <Calendar className="h-4 w-4" />
                          <span>{suggestion.estimatedDuration}m</span>
                        </div>
                      </div>
                      
                      <div className="mt-2">
                        <div className="flex items-center gap-1 mb-1">
                          <div className="w-2 h-2 bg-green-500 rounded-full"></div>
                          <span className="text-sm text-gray-600">Energy Match:</span>
                          <div className="flex-1 bg-gray-200 rounded-full h-1.5">
                            <div 
                              className="bg-green-500 h-1.5 rounded-full" 
                              style={{ width: `${suggestion.energyMatch * 100}%` }}
                            />
                          </div>
                          <span className="text-xs text-gray-500">
                            {Math.round(suggestion.energyMatch * 100)}%
                          </span>
                        </div>
                        <p className="text-xs text-gray-500 mt-1">
                          {suggestion.reasoning}
                        </p>
                      </div>
                    </div>
                    
                    <div className="flex items-center gap-2 ml-4">
                      {!task.completed && (
                        <>
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => handleTaskAction(task.id, 'start')}
                            className="flex items-center gap-1"
                          >
                            <Play className="h-3 w-3" />
                            Start
                          </Button>
                          <Button
                            variant="default"
                            size="sm"
                            onClick={() => handleTaskAction(task.id, 'complete')}
                            className="flex items-center gap-1"
                          >
                            <CheckCircle className="h-3 w-3" />
                            Done
                          </Button>
                        </>
                      )}
                      <Button variant="ghost" size="sm">
                        <MoreHorizontal className="h-4 w-4" />
                      </Button>
                    </div>
                  </div>
                </div>
              );
            })}
            
            <div className="pt-4 border-t">
              <div className="text-xs text-gray-500 text-center">
                Suggestions updated {format(new Date(), 'HH:mm')}
              </div>
            </div>
          </div>
        )}
      </CardContent>
    </Card>
  );
};
```

### 6. API Routes

Create `app/api/priorities/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';
import { z } from 'zod';

const PrioritySchema = z.object({
  taskId: z.string(),
  score: z.object({
    overall: z.number().min(0).max(100),
    urgency: z.number().min(0).max(40),
    importance: z.number().min(0).max(40),
    context: z.number().min(0).max(20),
    quadrant: z.enum(['do', 'schedule', 'delegate', 'delete']),
    level: z.enum(['low', 'medium', 'high', 'urgent']),
    explanation: z.string()
  }),
  manualOverride: z.enum(['low', 'medium', 'high', 'urgent']).optional(),
  suggestedTimeSlot: z.object({
    start: z.string(),
    end: z.string(),
    energyLevel: z.enum(['low', 'medium', 'high', 'peak'])
  }).optional()
});

export async function GET(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { searchParams } = new URL(request.url);
    const taskId = searchParams.get('taskId');

    let query = supabase
      .from('task_priorities')
      .select('*')
      .eq('user_id', user.id);

    if (taskId) {
      query = query.eq('task_id', taskId);
    }

    const { data: priorities, error } = await query;

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(priorities);
  } catch (error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const body = await request.json();
    const validatedData = PrioritySchema.parse(body);

    const { data: priority, error } = await supabase
      .from('task_priorities')
      .upsert({
        user_id: user.id,
        task_id: validatedData.taskId,
        overall_score: validatedData.score.overall,
        urgency_score: validatedData.score.urgency,
        importance_score: validatedData.score.importance,
        context_score: validatedData.score.context,
        quadrant: validatedData.score.quadrant,
        priority_level: validatedData.score.level,
        explanation: validatedData.score.explanation,
        manual_override: validatedData.manualOverride,
        suggested_time_slot: validatedData.suggestedTimeSlot,
        updated_at: new Date().toISOString()
      })
      .select()
      .single();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(priority);
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: 'Invalid request data', details: error.errors }, { status: 400 });
    }
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

Create `app/api/priorities/batch/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const priorities = await request.json();

    const priorityData = priorities.map((priority: any) => ({
      user_id: user.id,
      task_id: priority.taskId,
      overall_score: priority.score.overall,
      urgency_score: priority.score.urgency,
      importance_score: priority.score.importance,
      context_score: priority.score.context,
      quadrant: priority.score.quadrant,
      priority_level: priority.score.level,
      explanation: priority.score.explanation,
      manual_override: priority.manualOverride,
      suggested_time_slot: priority.suggestedTimeSlot,
      updated_at: new Date().toISOString()
    }));

    const { data, error } = await supabase
      .from('task_priorities')
      .upsert(priorityData)
      .select();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true, count: data.length });
  } catch (error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

Create `app/api/suggestions/daily/route.ts`:
```typescript
import { NextRequest, NextResponse } from 'next/server';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { cookies } from 'next/headers';

export async function GET(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const today = new Date().toISOString().split('T')[0];

    const { data: suggestions, error } = await supabase
      .from('daily_suggestions')
      .select('*')
      .eq('user_id', user.id)
      .eq('date', today)
      .order('priority', { ascending: false });

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json(suggestions);
  } catch (error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const suggestions = await request.json();
    const today = new Date().toISOString().split('T')[0];

    // Clear existing suggestions for today
    await supabase
      .from('daily_suggestions')
      .delete()
      .eq('user_id', user.id)
      .eq('date', today);

    // Insert new suggestions
    const suggestionData = suggestions.map((suggestion: any) => ({
      user_id: user.id,
      task_id: suggestion.taskId,
      date: today,
      priority: suggestion.priority,
      time_slot: suggestion.timeSlot,
      energy_match: suggestion.energyMatch,
      reasoning: suggestion.reasoning,
      estimated_duration: suggestion.estimatedDuration,
      created_at: new Date().toISOString()
    }));

    const { data, error } = await supabase
      .from('daily_suggestions')
      .insert(suggestionData)
      .select();

    if (error) {
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ success: true, count: data.length });
  } catch (error) {
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

### 7. Database Schema Updates

Required database tables for priority system:

```sql
-- Task priorities table
CREATE TABLE task_priorities (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  task_id uuid REFERENCES tasks(id) ON DELETE CASCADE,
  overall_score integer NOT NULL CHECK (overall_score >= 0 AND overall_score <= 100),
  urgency_score integer NOT NULL CHECK (urgency_score >= 0 AND urgency_score <= 40),
  importance_score integer NOT NULL CHECK (importance_score >= 0 AND importance_score <= 40),
  context_score integer NOT NULL CHECK (context_score >= 0 AND context_score <= 20),
  quadrant text NOT NULL CHECK (quadrant IN ('do', 'schedule', 'delegate', 'delete')),
  priority_level text NOT NULL CHECK (priority_level IN ('low', 'medium', 'high', 'urgent')),
  explanation text NOT NULL,
  manual_override text CHECK (manual_override IN ('low', 'medium', 'high', 'urgent')),
  suggested_time_slot jsonb,
  factors jsonb DEFAULT '[]'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now(),
  UNIQUE(user_id, task_id)
);

-- Daily suggestions table
CREATE TABLE daily_suggestions (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
  task_id uuid REFERENCES tasks(id) ON DELETE CASCADE,
  date date NOT NULL,
  priority integer NOT NULL,
  time_slot text NOT NULL,
  energy_match decimal(3,2) NOT NULL CHECK (energy_match >= 0 AND energy_match <= 1),
  reasoning text NOT NULL,
  estimated_duration integer NOT NULL,
  completed boolean DEFAULT false,
  created_at timestamptz DEFAULT now(),
  UNIQUE(user_id, task_id, date)
);

-- User energy patterns table
CREATE TABLE user_energy_patterns (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE UNIQUE,
  peak_hours integer[] DEFAULT '{9,10,11}'::integer[],
  high_hours integer[] DEFAULT '{14,15,16}'::integer[],
  medium_hours integer[] DEFAULT '{8,12,13,17}'::integer[],
  low_hours integer[] DEFAULT '{18,19,20}'::integer[],
  confidence decimal(3,2) DEFAULT 0.5 CHECK (confidence >= 0 AND confidence <= 1),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Indexes for performance
CREATE INDEX idx_task_priorities_user_id ON task_priorities(user_id);
CREATE INDEX idx_task_priorities_task_id ON task_priorities(task_id);
CREATE INDEX idx_task_priorities_quadrant ON task_priorities(quadrant);
CREATE INDEX idx_task_priorities_priority_level ON task_priorities(priority_level);
CREATE INDEX idx_daily_suggestions_user_date ON daily_suggestions(user_id, date);
CREATE INDEX idx_daily_suggestions_priority ON daily_suggestions(priority DESC);

-- RLS policies
ALTER TABLE task_priorities ENABLE ROW LEVEL SECURITY;
ALTER TABLE daily_suggestions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_energy_patterns ENABLE ROW LEVEL SECURITY;

-- Task priorities policies
CREATE POLICY "Users can view their own priorities" ON task_priorities
  FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own priorities" ON task_priorities
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own priorities" ON task_priorities
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own priorities" ON task_priorities
  FOR DELETE USING (auth.uid() = user_id);

-- Daily suggestions policies
CREATE POLICY "Users can view their own suggestions" ON daily_suggestions
  FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own suggestions" ON daily_suggestions
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own suggestions" ON daily_suggestions
  FOR UPDATE USING (auth.uid() = user_id);
CREATE POLICY "Users can delete their own suggestions" ON daily_suggestions
  FOR DELETE USING (auth.uid() = user_id);

-- Energy patterns policies
CREATE POLICY "Users can view their own energy patterns" ON user_energy_patterns
  FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can create their own energy patterns" ON user_energy_patterns
  FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Users can update their own energy patterns" ON user_energy_patterns
  FOR UPDATE USING (auth.uid() = user_id);
```

### 8. Testing Requirements

Create comprehensive tests for the priority system:

**Unit Tests:**
- Priority calculation algorithm accuracy
- Eisenhower Matrix quadrant assignment
- Energy level matching logic
- Daily suggestion generation

**Integration Tests:**
- API endpoints for priorities and suggestions
- Database operations and constraints
- Real-time priority updates

**E2E Tests:**
- Complete priority workflow from task creation to suggestion
- Manual priority overrides
- Priority-based task filtering and sorting

### 9. Error Handling & Edge Cases

**Priority Calculation:**
- Tasks with missing due dates
- Tasks with invalid importance levels
- Circular task dependencies
- Network failures during calculation

**Daily Suggestions:**
- No available tasks for suggestions
- Conflicting time slot requirements
- User energy pattern not available
- All suggested tasks completed

**Performance Considerations:**
- Batch priority calculation for large task lists
- Caching of frequently accessed priorities
- Debounced priority recalculation on task updates
- Background jobs for automated rescheduling

## Dependencies
- [ ] Task 004 completed (Tasks have priority field)
- [ ] Database functions available

## Effort Estimate
- Size: M
- Hours: 4
- Parallel: true

## Definition of Done
- [ ] Priority algorithm implemented
- [ ] Daily suggestions working
- [ ] Visual indicators clear
- [ ] Rescheduling tested
- [ ] Algorithm documented
